From 91779c895cc61f63ba94e7797a264a03cc2c514b Mon Sep 17 00:00:00 2001
From: ilobilo <ilia.chachanidze35@gmail.com>
Date: Fri, 10 Feb 2023 00:56:26 +0400
Subject: Add wip ilobilix sysdeps

---
 meson.build                                   |   4 +
 meson.build.orig                              | 402 +++++++++
 sysdeps/ilobilix/aarch64/crt-src/crt0.S       |   9 +
 sysdeps/ilobilix/aarch64/crt-src/crti.S       |  13 +
 sysdeps/ilobilix/aarch64/crt-src/crtn.S       |   9 +
 sysdeps/ilobilix/generic/entry.cpp            |  37 +
 sysdeps/ilobilix/generic/sysdeps.cpp          | 789 ++++++++++++++++++
 sysdeps/ilobilix/include/abi-bits/access.h    |   1 +
 sysdeps/ilobilix/include/abi-bits/auxv.h      |   1 +
 sysdeps/ilobilix/include/abi-bits/blkcnt_t.h  |   1 +
 sysdeps/ilobilix/include/abi-bits/blksize_t.h |   1 +
 sysdeps/ilobilix/include/abi-bits/clockid_t.h |   1 +
 sysdeps/ilobilix/include/abi-bits/dev_t.h     |   1 +
 sysdeps/ilobilix/include/abi-bits/epoll.h     |   1 +
 sysdeps/ilobilix/include/abi-bits/errno.h     |   1 +
 sysdeps/ilobilix/include/abi-bits/fcntl.h     |   1 +
 .../ilobilix/include/abi-bits/fsblkcnt_t.h    |   1 +
 .../ilobilix/include/abi-bits/fsfilcnt_t.h    |   1 +
 sysdeps/ilobilix/include/abi-bits/gid_t.h     |   1 +
 sysdeps/ilobilix/include/abi-bits/in.h        |   1 +
 sysdeps/ilobilix/include/abi-bits/ino_t.h     |   1 +
 sysdeps/ilobilix/include/abi-bits/inotify.h   |   1 +
 sysdeps/ilobilix/include/abi-bits/ioctls.h    |   1 +
 sysdeps/ilobilix/include/abi-bits/limits.h    |   1 +
 sysdeps/ilobilix/include/abi-bits/mode_t.h    |   1 +
 sysdeps/ilobilix/include/abi-bits/mqueue.h    |   1 +
 sysdeps/ilobilix/include/abi-bits/nlink_t.h   |   1 +
 sysdeps/ilobilix/include/abi-bits/packet.h    |   1 +
 sysdeps/ilobilix/include/abi-bits/pid_t.h     |   1 +
 sysdeps/ilobilix/include/abi-bits/poll.h      |   1 +
 sysdeps/ilobilix/include/abi-bits/ptrace.h    |   1 +
 sysdeps/ilobilix/include/abi-bits/reboot.h    |   1 +
 sysdeps/ilobilix/include/abi-bits/resource.h  |   1 +
 .../ilobilix/include/abi-bits/seek-whence.h   |   1 +
 sysdeps/ilobilix/include/abi-bits/shm.h       |   1 +
 sysdeps/ilobilix/include/abi-bits/signal.h    |   1 +
 sysdeps/ilobilix/include/abi-bits/socket.h    |   1 +
 sysdeps/ilobilix/include/abi-bits/socklen_t.h |   1 +
 sysdeps/ilobilix/include/abi-bits/stat.h      |   1 +
 sysdeps/ilobilix/include/abi-bits/statfs.h    |   1 +
 sysdeps/ilobilix/include/abi-bits/statvfs.h   |   1 +
 .../ilobilix/include/abi-bits/suseconds_t.h   |   1 +
 sysdeps/ilobilix/include/abi-bits/termios.h   |   1 +
 sysdeps/ilobilix/include/abi-bits/time.h      |   1 +
 sysdeps/ilobilix/include/abi-bits/uid_t.h     |   1 +
 sysdeps/ilobilix/include/abi-bits/utsname.h   |   1 +
 sysdeps/ilobilix/include/abi-bits/vm-flags.h  |   1 +
 sysdeps/ilobilix/include/abi-bits/vt.h        |   1 +
 sysdeps/ilobilix/include/abi-bits/wait.h      |   1 +
 sysdeps/ilobilix/include/abi-bits/xattr.h     |   1 +
 sysdeps/ilobilix/include/ilobilix/syscall.h   | 158 ++++
 sysdeps/ilobilix/meson.build                  |  93 +++
 sysdeps/ilobilix/x86_64/crt-src/crt0.S        |   8 +
 sysdeps/ilobilix/x86_64/crt-src/crti.S        |  11 +
 sysdeps/ilobilix/x86_64/crt-src/crtn.S        |   9 +
 55 files changed, 1585 insertions(+)
 create mode 100644 meson.build.orig
 create mode 100644 sysdeps/ilobilix/aarch64/crt-src/crt0.S
 create mode 100644 sysdeps/ilobilix/aarch64/crt-src/crti.S
 create mode 100644 sysdeps/ilobilix/aarch64/crt-src/crtn.S
 create mode 100644 sysdeps/ilobilix/generic/entry.cpp
 create mode 100644 sysdeps/ilobilix/generic/sysdeps.cpp
 create mode 120000 sysdeps/ilobilix/include/abi-bits/access.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/auxv.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/blkcnt_t.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/blksize_t.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/clockid_t.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/dev_t.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/epoll.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/errno.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/fcntl.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/fsblkcnt_t.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/fsfilcnt_t.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/gid_t.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/in.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/ino_t.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/inotify.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/ioctls.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/limits.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/mode_t.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/mqueue.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/nlink_t.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/packet.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/pid_t.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/poll.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/ptrace.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/reboot.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/resource.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/seek-whence.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/shm.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/signal.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/socket.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/socklen_t.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/stat.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/statfs.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/statvfs.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/suseconds_t.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/termios.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/time.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/uid_t.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/utsname.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/vm-flags.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/vt.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/wait.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/xattr.h
 create mode 100644 sysdeps/ilobilix/include/ilobilix/syscall.h
 create mode 100644 sysdeps/ilobilix/meson.build
 create mode 100644 sysdeps/ilobilix/x86_64/crt-src/crt0.S
 create mode 100644 sysdeps/ilobilix/x86_64/crt-src/crti.S
 create mode 100644 sysdeps/ilobilix/x86_64/crt-src/crtn.S

diff --git a/meson.build b/meson.build
index 79a64707..8e6262f1 100644
--- a/meson.build
+++ b/meson.build
@@ -146,6 +146,10 @@ elif host_machine.system() == 'lyre'
 	rtdl_include_dirs += include_directories('sysdeps/lyre/include')
 	libc_include_dirs += include_directories('sysdeps/lyre/include')
 	subdir('sysdeps/lyre')
+elif host_machine.system() == 'ilobilix'
+	rtdl_include_dirs += include_directories('sysdeps/ilobilix/include')
+	libc_include_dirs += include_directories('sysdeps/ilobilix/include')
+	subdir('sysdeps/ilobilix')
 elif host_machine.system() == 'lemon'
 	rtdl_include_dirs += include_directories('sysdeps/lemon/include')
 	libc_include_dirs += include_directories('sysdeps/lemon/include')
diff --git a/meson.build.orig b/meson.build.orig
new file mode 100644
index 00000000..79a64707
--- /dev/null
+++ b/meson.build.orig
@@ -0,0 +1,402 @@
+project('mlibc', default_options: ['warning_level=2', 'cpp_std=c++20'])
+
+fs = import('fs')
+
+rtdl_include_dirs = [
+	include_directories('options/internal/include'),
+	include_directories('options/internal' / host_machine.cpu_family() + '-include'),
+	include_directories('options/rtdl/include'),
+]
+libc_include_dirs = [
+	include_directories('options/internal/include'),
+	include_directories('options/elf/include'),
+	include_directories('options/lsb/include'),
+	include_directories('options/rtdl/include'),
+	include_directories('options/internal' / host_machine.cpu_family() + '-include')
+]
+
+rtdl_sources = [ ]
+rtdl_dso_sources = [ ]
+libc_sources = [ ]
+libc_sublibs = [ ]
+
+libc_deps = [ ]
+rtdl_deps = [ ]
+
+headers_only = get_option('headers_only')
+no_headers = get_option('mlibc_no_headers')
+library_type = get_option('default_library')
+build_tests = get_option('build_tests')
+build_tests_host_libc = get_option('build_tests_host_libc')
+disable_ansi_option = get_option('disable_ansi_option')
+disable_posix_option = get_option('disable_posix_option')
+disable_linux_option = get_option('disable_linux_option')
+disable_iconv_option = get_option('disable_iconv_option')
+disable_intl_option = get_option('disable_intl_option')
+disable_glibc_option = get_option('disable_glibc_option')
+disable_crypt_option = get_option('disable_crypt_option')
+disable_bsd_option = get_option('disable_bsd_option')
+internal_conf = configuration_data()
+mlibc_conf = configuration_data()
+
+if not headers_only
+	cxxshim_dep = dependency('cxxshim', fallback: ['cxxshim', 'cxxshim_dep'])
+	libc_deps += cxxshim_dep
+	rtdl_deps += cxxshim_dep
+
+	frigg_dep = dependency(
+		'frigg',
+		default_options: ['frigg_no_install=true'],
+		fallback: ['frigg', 'frigg_dep'],
+	)
+	libc_deps += frigg_dep
+	rtdl_deps += frigg_dep
+
+	add_languages('c', 'cpp')
+	c_compiler = meson.get_compiler('c')
+
+	add_project_arguments('-Wno-unused-function', '-D__MLIBC_BUILDING_MLIBC', language: ['c', 'cpp'])
+	add_project_arguments('-nostdinc', '-fno-builtin', language: ['c', 'cpp'])
+	add_project_arguments('-Werror=misleading-indentation', language: ['c', 'cpp'])
+	add_project_arguments('-fno-rtti', '-fno-exceptions', language: 'cpp')
+	add_project_link_arguments('-nostdlib', language: ['c', 'cpp'])
+
+	searchdirs = run_command(c_compiler.cmd_array(), '-print-search-dirs',
+				check: true).stdout()
+	searchdirs_arr = searchdirs.split('\n')
+	searchline = 'install: '
+	ccdir = ''
+	if c_compiler.get_id() == 'clang'
+		searchline = 'libraries: ='
+	endif
+
+	foreach line : searchdirs_arr
+		if line.startswith(searchline)
+			ccdir = line.strip(searchline)
+			ccdir = ccdir.split(':')[0]
+			break
+		endif
+	endforeach
+
+	if ccdir == ''
+		error('could not find compiler-specific header directory')
+	endif
+
+	if c_compiler.get_id() == 'gcc' and fs.exists(ccdir / 'include-fixed')
+		rtdl_include_dirs += include_directories(ccdir / 'include-fixed')
+		libc_include_dirs += include_directories(ccdir / 'include-fixed')
+	endif
+
+	rtdl_include_dirs += include_directories(ccdir / 'include')
+	libc_include_dirs += include_directories(ccdir / 'include')
+endif
+
+internal_conf.set_quoted('MLIBC_SYSTEM_NAME', host_machine.system())
+internal_conf.set10('MLIBC_MAP_DSO_SEGMENTS', false)
+internal_conf.set10('MLIBC_MMAP_ALLOCATE_DSO', false)
+internal_conf.set10('MLIBC_MAP_FILE_WINDOWS', false)
+internal_conf.set10('MLIBC_DEBUG_ALLOCATOR', get_option('debug_allocator'))
+
+#----------------------------------------------------------------------------------------
+# Configuration based on sysdeps.
+#----------------------------------------------------------------------------------------
+
+# Process sysdeps first, as sysdeps might want to disable unsupported options.
+provides_bits_syscall_h = false
+if host_machine.system() == 'linux'
+	provides_bits_syscall_h = true
+	rtdl_include_dirs += include_directories('sysdeps/linux/include')
+	libc_include_dirs += include_directories('sysdeps/linux/include')
+
+	if get_option('linux_kernel_headers') == ''
+		error('linux_kernel_headers is not set')
+	endif
+
+	if not import('fs').is_dir(get_option('linux_kernel_headers'))
+		error('linux_kernel_headers is not set to a valid path')
+	endif
+
+	rtdl_include_dirs += include_directories(get_option('linux_kernel_headers'))
+	libc_include_dirs += include_directories(get_option('linux_kernel_headers'))
+
+	internal_conf.set10('MLIBC_MAP_DSO_SEGMENTS', true)
+	internal_conf.set10('MLIBC_MMAP_ALLOCATE_DSO', true)
+	subdir('sysdeps/linux')
+elif host_machine.system() == 'aero'
+	rtdl_include_dirs += include_directories('sysdeps/aero/include')
+	libc_include_dirs += include_directories('sysdeps/aero/include')
+	subdir('sysdeps/aero')
+elif host_machine.system() == 'managarm'
+	# TODO: Adopt the include_directories() commands from the managarm meson.build.
+	rtdl_include_dirs += include_directories('sysdeps/managarm/include')
+	libc_include_dirs += include_directories('sysdeps/managarm/include')
+	internal_conf.set10('MLIBC_MAP_DSO_SEGMENTS', true)
+	internal_conf.set10('MLIBC_MAP_FILE_WINDOWS', true)
+	subdir('sysdeps/managarm')
+elif host_machine.system() == 'ironclad'
+	# disable_linux_option = true
+	rtdl_include_dirs += include_directories('sysdeps/ironclad/include')
+	libc_include_dirs += include_directories('sysdeps/ironclad/include')
+	subdir('sysdeps/ironclad')
+elif host_machine.system() == 'vinix'
+	rtdl_include_dirs += include_directories('sysdeps/vinix/include')
+	libc_include_dirs += include_directories('sysdeps/vinix/include')
+	subdir('sysdeps/vinix')
+elif host_machine.system() == 'lyre'
+	rtdl_include_dirs += include_directories('sysdeps/lyre/include')
+	libc_include_dirs += include_directories('sysdeps/lyre/include')
+	subdir('sysdeps/lyre')
+elif host_machine.system() == 'lemon'
+	rtdl_include_dirs += include_directories('sysdeps/lemon/include')
+	libc_include_dirs += include_directories('sysdeps/lemon/include')
+	subdir('sysdeps/lemon')
+elif host_machine.system() == 'dripos'
+	disable_linux_option = true
+	rtdl_include_dirs += include_directories('sysdeps/dripos/include')
+	libc_include_dirs += include_directories('sysdeps/dripos/include')
+	subdir('sysdeps/dripos')
+else
+	error('No sysdeps defined for OS: ' + host_machine.system())
+endif
+
+#----------------------------------------------------------------------------------------
+# Configuration based on enabled options.
+#----------------------------------------------------------------------------------------
+
+mlibc_conf.set10('__MLIBC_ANSI_OPTION', not disable_ansi_option)
+mlibc_conf.set10('__MLIBC_POSIX_OPTION', not disable_posix_option)
+mlibc_conf.set10('__MLIBC_LINUX_OPTION', not disable_linux_option)
+mlibc_conf.set10('__MLIBC_INTL_OPTION', not disable_intl_option)
+mlibc_conf.set10('__MLIBC_ICONV_OPTION', not disable_iconv_option)
+mlibc_conf.set10('__MLIBC_GLIBC_OPTION', not disable_glibc_option)
+mlibc_conf.set10('__MLIBC_CRYPT_OPTION', not disable_crypt_option)
+mlibc_conf.set10('__MLIBC_BSD_OPTION', not disable_bsd_option)
+mlibc_conf.set10('__MLIBC_SYSDEP_HAS_BITS_SYSCALL_H', provides_bits_syscall_h)
+
+if not disable_ansi_option
+	rtdl_include_dirs += include_directories('options/ansi/include')
+	libc_include_dirs += include_directories('options/ansi/include')
+endif
+
+if not disable_posix_option
+	rtdl_include_dirs += include_directories('options/posix/include')
+	libc_include_dirs += include_directories('options/posix/include')
+endif
+
+if not disable_iconv_option
+	rtdl_include_dirs += include_directories('options/iconv/include')
+	libc_include_dirs += include_directories('options/iconv/include')
+endif
+
+if not disable_intl_option
+	libc_include_dirs += include_directories('options/intl/include')
+endif
+
+if not disable_linux_option
+	if get_option('linux_kernel_headers') == ''
+		error('linux_kernel_headers is not set')
+	endif
+
+	if not import('fs').is_dir(get_option('linux_kernel_headers'))
+		error('linux_kernel_headers is not set to a valid path')
+	endif
+
+	rtdl_include_dirs += include_directories('options/linux/include')
+	libc_include_dirs += include_directories('options/linux/include')
+	rtdl_include_dirs += include_directories(get_option('linux_kernel_headers'))
+	libc_include_dirs += include_directories(get_option('linux_kernel_headers'))
+endif
+
+if not disable_glibc_option
+	rtdl_include_dirs += include_directories('options/glibc/include')
+	libc_include_dirs += include_directories('options/glibc/include')
+endif
+
+if not disable_crypt_option
+	libc_include_dirs += include_directories('options/crypt/include')
+endif
+
+if not disable_bsd_option
+	libc_include_dirs += include_directories('options/bsd/include')
+endif
+
+rtdl_include_dirs += include_directories('options/elf/include')
+libc_include_dirs += include_directories('options/elf/include')
+libc_include_dirs += include_directories('.')
+
+#----------------------------------------------------------------------------------------
+
+configure_file(input: 'internal-config.h.in',
+	output: 'internal-config.h',
+	configuration: internal_conf)
+
+configure_file(input: 'mlibc-config.h.in',
+	output: 'mlibc-config.h',
+	configuration: mlibc_conf,
+	install: not no_headers,
+	install_dir: get_option('includedir'))
+
+internal_sources = [
+	'options/internal/generic/allocator.cpp',
+	'options/internal/generic/charcode.cpp',
+	'options/internal/generic/charset.cpp',
+	'options/internal/generic/debug.cpp',
+	'options/internal/generic/ensure.cpp',
+	'options/internal/generic/essential.cpp',
+	'options/internal/generic/frigg.cpp',
+	'options/internal/generic/global-config.cpp',
+	'options/internal/generic/inline-emitter.cpp',
+	'options/internal/generic/locale.cpp',
+	'options/internal/generic/sigset.cpp',
+	'options/internal/generic/strings.cpp',
+	'options/internal/generic/ubsan.cpp',
+	'options/internal/gcc/stack_protector.cpp',
+	'options/internal/gcc/guard-abi.cpp',
+	'options/internal/gcc/initfini.cpp',
+	'options/internal/gcc-extra/cxxabi.cpp',
+	'options/internal' / host_machine.cpu_family() / 'setjmp.S',
+	'options/internal' / host_machine.cpu_family() / 'fenv.S',
+]
+
+internal_dso_sources = [
+	'options/internal/gcc-extra/mlibc_crtbegin.S',
+	'options/internal' / host_machine.cpu_family() / 'mlibc_crtend.S',
+]
+
+if not no_headers
+	install_headers(
+		'options/internal/include/stdint.h'
+	)
+	install_headers(
+		'options/internal/include/bits/wchar_t.h',
+		'options/internal/include/bits/wchar.h',
+		'options/internal/include/bits/wint_t.h',
+		'options/internal/include/bits/size_t.h',
+		'options/internal/include/bits/types.h',
+		'options/internal/include/bits/ensure.h',
+		'options/internal/include/bits/machine.h',
+		'options/internal/include/bits/mbstate.h',
+		'options/internal/include/bits/nl_item.h',
+		'options/internal/include/bits/null.h',
+		'options/internal/include/bits/off_t.h',
+		'options/internal/include/bits/ssize_t.h',
+		'options/internal/include/bits/sigset_t.h',
+		'options/internal/include/bits/inline-definition.h',
+		subdir: 'bits'
+	)
+endif
+
+rtdl_sources += [
+	'options/internal/gcc/stack_protector.cpp',
+	'options/internal/gcc/guard-abi.cpp',
+	'options/internal/generic/allocator.cpp',
+	'options/internal/generic/debug.cpp',
+	'options/internal/generic/ensure.cpp',
+	'options/internal/generic/essential.cpp',
+	'options/internal/generic/inline-emitter.cpp',
+	'options/internal/generic/frigg.cpp',
+	'options/internal/generic/ubsan.cpp',
+	'options/rtdl/generic/main.cpp',
+	'options/rtdl/generic/linker.cpp',
+	'options/rtdl' / host_machine.cpu_family() / 'runtime.S'
+]
+
+rtdl_dso_sources += ['options/rtdl' / host_machine.cpu_family() / 'entry.S']
+
+subdir('options/elf')
+subdir('options/ansi')
+subdir('options/posix')
+subdir('options/lsb')
+subdir('options/glibc')
+subdir('options/linux')
+subdir('options/iconv')
+subdir('options/intl')
+subdir('options/crypt')
+subdir('options/bsd')
+
+rtlib_deps = []
+
+if not headers_only
+	if host_machine.cpu_family() == 'aarch64' or host_machine.cpu_family() == 'riscv64'
+		# Some architectures require us to link with libgcc or compiler_rt
+		libgcc = meson.get_compiler('c').find_library('gcc', required: false)
+
+		compiler_rt_name = 'libclang_rt.builtins-' + host_machine.cpu_family()
+		compiler_rt = meson.get_compiler('c').find_library(compiler_rt_name, required: false)
+
+		if libgcc.found()
+			rtlib_deps += libgcc
+		elif compiler_rt.found()
+			rtlib_deps += compiler_rt
+		else
+			error('neither libgcc nor ' + compiler_rt_name + ' was found')
+		endif
+	endif
+
+	ld_cpp_args = [
+		'-fvisibility=hidden',
+		'-fno-stack-protector',
+		'-DMLIBC_BUILDING_RTDL'
+	]
+
+	libc_all_sources = [
+		libc_sources,
+		internal_sources,
+		ansi_sources,
+		lsb_sources,
+	]
+
+	# Our library have different behaviour when built as static and shared libraries.
+	# Hence we need to rebuild the object files with a different define for each mode.
+	if library_type in ['static', 'both']
+		static_cpp_args = [
+			'-DMLIBC_STATIC_BUILD',
+			'-DFRIGG_HAVE_LIBC',
+		]
+		ld_static_lib = static_library('ld', rtdl_sources,
+			name_prefix: '',
+			cpp_args: ld_cpp_args + static_cpp_args,
+			include_directories: rtdl_include_dirs,
+			dependencies: rtdl_deps + rtlib_deps,
+			install: false
+		)
+		libc_static = static_library('c', libc_all_sources,
+			cpp_args: static_cpp_args + ['-fno-stack-protector'],
+			include_directories: libc_include_dirs,
+			dependencies: libc_deps + rtlib_deps,
+			link_with: [ld_static_lib],
+			link_whole: [libc_sublibs, ld_static_lib],
+			install: true
+		)
+	endif
+	if library_type in ['shared', 'both']
+		ld_shared_lib = shared_library('ld', rtdl_sources + rtdl_dso_sources,
+			name_prefix: '',
+			cpp_args: ld_cpp_args,
+			include_directories: rtdl_include_dirs,
+			dependencies: rtdl_deps + rtlib_deps,
+			install: true
+		)
+		libc_shared = shared_library('c', libc_all_sources + internal_dso_sources,
+			include_directories: libc_include_dirs,
+			dependencies: libc_deps + rtlib_deps,
+			link_with: [ld_shared_lib],
+			link_whole: libc_sublibs,
+			install: true
+		)
+	endif
+
+	library('pthread', 'dummy-libs/libpthread/src/dummy.cpp', install: true)
+	library('rt', 'dummy-libs/librt/src/dummy.cpp', install: true)
+	library('util', 'dummy-libs/libutil/src/dummy.cpp', install: true)
+	library('m', 'dummy-libs/libm/src/dummy.cpp', install: true)
+	if not disable_crypt_option
+		library('crypt', 'dummy-libs/libcrypt/src/dummy.cpp', install: true)
+	endif
+	library('resolv', 'dummy-libs/libresolv/src/dummy.cpp', install: true)
+	library('dl', 'dummy-libs/libdl/src/dummy.cpp', install: true)
+endif
+
+if build_tests
+	subdir('tests/')
+endif
diff --git a/sysdeps/ilobilix/aarch64/crt-src/crt0.S b/sysdeps/ilobilix/aarch64/crt-src/crt0.S
new file mode 100644
index 00000000..91170a76
--- /dev/null
+++ b/sysdeps/ilobilix/aarch64/crt-src/crt0.S
@@ -0,0 +1,9 @@
+.section .text
+.global _start
+_start:
+	adrp x0, main
+	add x0, x0, :lo12:main
+	bl __mlibc_entry
+
+.section .note.GNU-stack,"",%progbits
+
diff --git a/sysdeps/ilobilix/aarch64/crt-src/crti.S b/sysdeps/ilobilix/aarch64/crt-src/crti.S
new file mode 100644
index 00000000..0f5ca0f1
--- /dev/null
+++ b/sysdeps/ilobilix/aarch64/crt-src/crti.S
@@ -0,0 +1,13 @@
+.section .init
+.global _init
+_init:
+	stp x29, x30, [sp, -16]!
+	mov x29, sp
+
+.section .fini
+.global _fini
+_fini:
+	stp x29, x30, [sp, -16]!
+	mov x29, sp
+.section .note.GNU-stack,"",%progbits
+
diff --git a/sysdeps/ilobilix/aarch64/crt-src/crtn.S b/sysdeps/ilobilix/aarch64/crt-src/crtn.S
new file mode 100644
index 00000000..cd95321a
--- /dev/null
+++ b/sysdeps/ilobilix/aarch64/crt-src/crtn.S
@@ -0,0 +1,9 @@
+.section .init
+	ldp x29, x30, [sp], #16
+	ret
+
+.section .fini
+	ldp x29, x30, [sp], #16
+	ret
+.section .note.GNU-stack,"",%progbits
+
diff --git a/sysdeps/ilobilix/generic/entry.cpp b/sysdeps/ilobilix/generic/entry.cpp
new file mode 100644
index 00000000..62b1c3cb
--- /dev/null
+++ b/sysdeps/ilobilix/generic/entry.cpp
@@ -0,0 +1,37 @@
+#include <mlibc/elf/startup.h>
+#include <ilobilix/syscall.h>
+#include <stdint.h>
+#include <stdlib.h>
+
+// defined by the POSIX library
+void __mlibc_initLocale();
+
+extern "C" uintptr_t *__dlapi_entrystack();
+extern "C" void __dlapi_enter(uintptr_t *);
+
+extern char **environ;
+static mlibc::exec_stack_data __mlibc_stack_data;
+
+struct LibraryGuard
+{
+	LibraryGuard();
+};
+
+static LibraryGuard guard;
+
+LibraryGuard::LibraryGuard()
+{
+	__mlibc_initLocale();
+
+	// Parse the exec() stack.
+	mlibc::parse_exec_stack(__dlapi_entrystack(), &__mlibc_stack_data);
+	mlibc::set_startup_data(__mlibc_stack_data.argc, __mlibc_stack_data.argv, __mlibc_stack_data.envp);
+}
+
+extern "C" void __mlibc_entry(uintptr_t *entry_stack, int (*main_fn)(int argc, char *argv[], char *env[]))
+{
+	__dlapi_enter(entry_stack);
+	auto result = main_fn(__mlibc_stack_data.argc, __mlibc_stack_data.argv, environ);
+	exit(result);
+}
+
diff --git a/sysdeps/ilobilix/generic/sysdeps.cpp b/sysdeps/ilobilix/generic/sysdeps.cpp
new file mode 100644
index 00000000..0603b3a4
--- /dev/null
+++ b/sysdeps/ilobilix/generic/sysdeps.cpp
@@ -0,0 +1,789 @@
+#include <bits/ensure.h>
+#include <mlibc/allocator.hpp>
+#include <mlibc/debug.hpp>
+#include <mlibc/all-sysdeps.hpp>
+#include <errno.h>
+#include <dirent.h>
+#include <fcntl.h>
+#include <limits.h>
+#include <asm/ioctls.h>
+#include <stdlib.h>
+#include <abi-bits/fcntl.h>
+#include <ilobilix/syscall.h>
+
+#define STUB_ONLY(name)                               \
+{                                                     \
+	sys_libc_log("mlibc: sys_" #name "() is a stub"); \
+	return 0;                                         \
+}
+
+namespace mlibc {
+
+inline uintptr_t __do_syscall(uintptr_t n, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4, uintptr_t a5, uintptr_t a6)
+{
+	return __syscall(n, a1, a2, a3, a4, a5, a6);
+}
+
+inline uintptr_t __do_syscall(uintptr_t n, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4, uintptr_t a5)
+{
+	return __syscall(n, a1, a2, a3, a4, a5);
+}
+
+inline uintptr_t __do_syscall(uintptr_t n, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4)
+{
+	return __syscall(n, a1, a2, a3, a4);
+}
+
+inline uintptr_t __do_syscall(uintptr_t n, uintptr_t a1, uintptr_t a2, uintptr_t a3)
+{
+	return __syscall(n, a1, a2, a3);
+}
+
+inline uintptr_t __do_syscall(uintptr_t n, uintptr_t a1, uintptr_t a2)
+{
+	return __syscall(n, a1, a2);
+}
+
+inline uintptr_t __do_syscall(uintptr_t n, uintptr_t a1)
+{
+	return __syscall(n, a1);
+}
+
+inline uintptr_t __do_syscall(uintptr_t n)
+{
+	return __syscall(n);
+}
+
+// Perhaps move do_syscall in syscall.h
+
+template<typename ...Args>
+requires (sizeof...(Args) > 0 && sizeof...(Args) <= 7)
+inline uintptr_t do_syscall(Args &&...args)
+{
+	return __do_syscall(uintptr_t(args)...);
+}
+
+inline int syscall_error(intptr_t ret)
+{
+	auto v = static_cast<intptr_t>(ret);
+	if(static_cast<uintptr_t>(v) > -4096UL)
+		return -v;
+	return 0;
+}
+
+// void sys_libc_log(const char *message)
+// {
+// 	size_t n = 0;
+// 	while(message[n])
+// 		n++;
+// 	do_syscall(SYS_write, 2, message, n);
+// 	char lf = '\n';
+// 	do_syscall(SYS_write, 2, &lf, 1);
+// }
+
+void sys_libc_log(const char *_message)
+{
+	auto len = strlen(_message);
+	char *message = static_cast<char*>(alloca(len + 1));
+
+	memcpy(message, _message, len);
+	message[len] = '\n';
+
+	do_syscall(SYS_write, 2, message, len + 1);
+}
+
+void sys_libc_panic()
+{
+	sys_libc_log("\nMLIBC PANIC\n");
+	sys_exit(1);
+	__builtin_unreachable();
+}
+
+void sys_exit(int status)
+{
+	do_syscall(SYS_exit, status);
+	__builtin_unreachable();
+}
+
+int sys_tcb_set(void *pointer)
+{
+#if defined(__x86_64__)
+	do_syscall(SYS_arch_prctl, 0x1002 /* ARCH_SET_FS */, pointer);
+#elif defined(__aarch64__)
+	uintptr_t thread_data = reinterpret_cast<uintptr_t>(pointer) + sizeof(Tcb) - 0x10;
+	asm volatile ("msr tpidr_el0, %0" :: "r"(thread_data));
+#else
+#	error "Missing architecture specific code."
+#endif
+	return 0;
+}
+
+int sys_futex_wait(int *pointer, int expected, const struct timespec *time) STUB_ONLY(futex_wait)
+// {
+// 	return do_syscall(SYS_futex_wait, pointer, expected, time);
+// }
+
+int sys_futex_wake(int *pointer) STUB_ONLY(futex_wake)
+// {
+// 	auto ret = do_syscall(SYS_futex_wake, pointer);
+
+// 	if (auto e = syscall_error(ret); e)
+// 		return e;
+
+// 	int num_woken = ret;
+
+// 	__ensure(num_woken >= 0 && num_woken <= 1);
+// 	return num_woken;
+// }
+
+int sys_openat(int dirfd, const char *path, int flags, mode_t mode, int *fd)
+{
+	auto ret = do_syscall(SYS_openat, dirfd, path, flags, mode);
+
+	if (auto e = syscall_error(ret); e)
+		return e;
+
+	*fd = int(ret);
+	return 0;
+}
+
+int sys_open(const char *path, int flags, mode_t mode, int *fd)
+{
+	return sys_openat(AT_FDCWD, path, flags, mode, fd);
+}
+
+int sys_close(int fd)
+{
+	auto ret = do_syscall(SYS_close, fd);
+	if (auto e = syscall_error(ret); e)
+		return e;
+	return 0;
+}
+
+int sys_seek(int fd, off_t offset, int whence, off_t *new_offset)
+{
+	auto ret = do_syscall(SYS_lseek, fd, offset, whence);
+	if (auto e = syscall_error(ret); e)
+		return e;
+
+	*new_offset = off_t(ret);
+	return 0;
+}
+
+int sys_read(int fd, void *buf, size_t count, ssize_t *bytes_read)
+{
+	auto ret = do_syscall(SYS_read, fd, buf, count);
+	if (auto e = syscall_error(ret); e)
+		return e;
+
+	*bytes_read = ssize_t(ret);
+	return 0;
+}
+
+int sys_vm_map(void *hint, size_t size, int prot, int flags, int fd, off_t offset, void **window)
+{
+	auto ret = do_syscall(SYS_mmap, hint, size, prot, flags, fd, offset);
+	if (auto e = syscall_error(ret); e)
+		return e;
+
+	*window = (void*)ret;
+	return 0;
+}
+
+int sys_vm_unmap(void *pointer, size_t size)
+{
+	auto ret = do_syscall(SYS_munmap, pointer, size);
+	if (auto e = syscall_error(ret); e)
+		return e;
+	return 0;
+}
+
+int sys_anon_allocate(size_t size, void **pointer)
+{
+	return sys_vm_map(NULL, size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0, pointer);
+}
+
+int sys_anon_free(void *pointer, size_t size)
+{
+	return sys_vm_unmap(pointer, size);
+}
+
+// All remaining functions are disabled in ldso.
+#ifndef MLIBC_BUILDING_RTDL
+
+// int sys_kill(pid_t, int)
+
+int sys_fork(pid_t *child)
+{
+#if defined(__x86_64__)
+	// internally sys_fork uses sys_clone
+	auto ret = do_syscall(SYS_fork);
+#elif defined(__aarch64__)
+	auto ret = do_syscall(SYS_clone, SIGCHLD, 0);
+#else
+#	error "Missing architecture specific code."
+#endif
+	if (int e = syscall_error(ret); e)
+		return e;
+	*child = int(ret);
+	return 0;
+}
+
+int sys_tcgetattr(int fd, struct termios *attr)
+{
+	int ret;
+	if (int r = sys_ioctl(fd, TCGETS, attr, &ret) != 0)
+		return r;
+
+	return 0;
+}
+
+int sys_tcsetattr(int fd, int optional_action, const struct termios *attr)
+{
+	int ret;
+	switch (optional_action)
+	{
+		case TCSANOW:
+			optional_action = TCSETS;
+			break;
+		case TCSADRAIN:
+			optional_action = TCSETSW;
+			break;
+		case TCSAFLUSH:
+			optional_action = TCSETSF;
+			break;
+		default:
+			__ensure(!"Unsupported tcsetattr");
+	}
+
+	if (int r = sys_ioctl(fd, optional_action, (void *)attr, &ret) != 0)
+		return r;
+
+	return 0;
+}
+
+// int sys_timerfd_create(int, int *)
+
+int sys_ioctl(int fd, unsigned long request, void *arg, int *result)
+{
+	auto ret = do_syscall(SYS_ioctl, fd, request, arg);
+	if (auto e = syscall_error(ret); e)
+		return e;
+
+	*result = int(ret);
+	return 0;
+}
+
+int sys_isatty(int fd)
+{
+	struct winsize ws;
+	int ret;
+
+	if (!sys_ioctl(fd, TIOCGWINSZ, &ws, &ret))
+		return 0;
+
+	return ENOTTY;
+}
+
+gid_t sys_getgid() STUB_ONLY(getgid)
+gid_t sys_getegid() STUB_ONLY(getegid)
+uid_t sys_getuid() STUB_ONLY(getuid)
+uid_t sys_geteuid() STUB_ONLY(geteuid)
+pid_t sys_getpid()
+{
+	return pid_t(do_syscall(SYS_getpid));
+}
+pid_t sys_gettid() STUB_ONLY(gettid)
+pid_t sys_getppid()
+{
+	return pid_t(do_syscall(SYS_getppid));
+}
+pid_t sys_getpgid(pid_t pid, pid_t *pgid) STUB_ONLY(getpgid)
+pid_t sys_getsid(pid_t pid, pid_t *sid) STUB_ONLY(getsid)
+
+int sys_setpgid(pid_t pid, pid_t pgid) STUB_ONLY(setpgid)
+int sys_setuid(uid_t uid) STUB_ONLY(setuid)
+int sys_seteuid(uid_t euid) STUB_ONLY(seteuid)
+int sys_setgid(gid_t gid) STUB_ONLY(setgid)
+int sys_setegid(gid_t egid) STUB_ONLY(setegid)
+
+// TODO
+int sys_ttyname(int, char *, size_t)
+{
+	return ENOSYS;
+}
+
+int sys_clock_get(int clock, time_t *secs, long *nanos) STUB_ONLY(clock_get)
+// {
+// 	struct timespec buf;
+// 	auto ret = do_syscall(SYS_getclock, clock, &buf);
+// 	if (auto e = syscall_error(ret); e)
+//		return e;
+
+// 	*secs = buf.tv_sec;
+// 	*nanos = buf.tv_nsec;
+// 	return 0;
+// }
+
+int sys_getcwd(char *buffer, size_t size)
+{
+	auto ret = do_syscall(SYS_getcwd, buffer, size);
+	if (auto e = syscall_error(ret); e)
+		return e;
+
+	return 0;
+}
+
+int sys_stat(fsfd_target fsfdt, int fd, const char *path, int flags, struct stat *statbuf)
+{
+	uintptr_t ret = 0;
+	switch (fsfdt)
+	{
+		case fsfd_target::fd:
+			ret = do_syscall(SYS_fstatat, fd, "", statbuf, flags | AT_EMPTY_PATH);
+			break;
+		case fsfd_target::path:
+			ret = do_syscall(SYS_fstatat, AT_FDCWD, path, statbuf, flags);
+			break;
+		case fsfd_target::fd_path:
+			ret = do_syscall(SYS_fstatat, fd, path, statbuf, flags);
+			break;
+		default:
+			__ensure(!"sys_stat: Invalid fsfdt");
+			__builtin_unreachable();
+	}
+	if (auto e = syscall_error(ret); e)
+		return e;
+	return 0;
+}
+
+int sys_faccessat(int dirfd, const char *pathname, int mode, int flags)
+{
+	(void)flags;
+	struct stat buf;
+	if (int r = sys_stat(fsfd_target::fd_path, dirfd, pathname, mode & AT_SYMLINK_FOLLOW, &buf))
+		return r;
+
+	return 0;
+}
+
+int sys_access(const char *path, int mode)
+{
+	return sys_faccessat(AT_FDCWD, path, mode, 0);
+}
+
+int sys_open_dir(const char *path, int *handle)
+{
+	return sys_openat(AT_FDCWD, path, O_DIRECTORY, 0, handle);
+}
+
+int sys_read_entries(int handle, void *buffer, size_t max_size, size_t *bytes_read)
+{
+	auto ret = do_syscall(SYS_getdents64, handle, buffer, max_size);
+	if (auto e = syscall_error(ret); e)
+		return e;
+
+	*bytes_read = int(ret);
+	return 0;
+}
+
+// int sys_pipe(int *fds, int flags)
+// {
+// 	auto ret = do_syscall(SYS_pipe, fds, flags);
+// 	if (auto e = syscall_error(ret); e)
+//		return e;
+// 	return 0;
+// }
+
+int sys_chdir(const char *path)
+{
+	auto ret = do_syscall(SYS_chdir, path);
+	if (auto e = syscall_error(ret); e)
+		return e;
+	return 0;
+}
+
+int sys_fchdir(int fd)
+{
+	auto ret = do_syscall(SYS_chdir, fd);
+	if (auto e = syscall_error(ret); e)
+		return e;
+	return 0;
+}
+
+// int sys_mkdir(const char *path, mode_t mode)
+// {
+// 	return sys_mkdirat(AT_FDCWD, path, mode);
+// }
+
+// int sys_mkdirat(int dirfd, const char *path, mode_t mode)
+// {
+// 	auto ret = do_syscall(SYS_mkdirat, dirfd, path, mode);
+// 	if (auto e = syscall_error(ret); e)
+//		return e;
+// 	return 0;
+// }
+
+int sys_write(int fd, const void *buf, size_t count, ssize_t *bytes_written)
+{
+	auto ret = do_syscall(SYS_write, fd, buf, count);
+	if (auto e = syscall_error(ret); e)
+		return e;
+
+	*bytes_written = ssize_t(ret);
+	return 0;
+}
+
+int sys_readlink(const char *path, void *data, size_t max_size, ssize_t *length)
+{
+	auto ret = do_syscall(SYS_readlinkat, AT_FDCWD, path, data, max_size);
+	if (auto e = syscall_error(ret); e)
+		return e;
+
+	*length = ssize_t(ret);
+	return 0;
+}
+
+int sys_link(const char *old_path, const char *new_path)
+{
+	return sys_linkat(AT_FDCWD, old_path, AT_FDCWD, new_path, 0);
+}
+
+int sys_linkat(int olddirfd, const char *old_path, int newdirfd, const char *new_path, int flags)
+{
+	auto ret = do_syscall(SYS_linkat, olddirfd, old_path, newdirfd, new_path, flags);
+	if (auto e = syscall_error(ret); e)
+		return e;
+
+	return 0;
+}
+
+int sys_unlinkat(int fd, const char *path, int flags)
+{
+	auto ret = do_syscall(SYS_unlinkat, fd, path, flags);
+	if (auto e = syscall_error(ret); e)
+		return e;
+
+	return 0;
+}
+
+int sys_fchmodat(int fd, const char *pathname, mode_t mode, int flags)
+{
+	auto ret = do_syscall(SYS_fchmodat, fd, pathname, mode, flags);
+	if (auto e = syscall_error(ret); e)
+		return e;
+
+	return 0;
+}
+
+int sys_fchmod(int fd, mode_t mode)
+{
+	return sys_fchmodat(fd, "", mode, AT_EMPTY_PATH);
+}
+
+int sys_chmod(const char *pathname, mode_t mode)
+{
+	return sys_fchmodat(AT_FDCWD, pathname, mode, 0);
+}
+
+// int sys_rmdir(const char *pathname)
+// {
+// 	auto ret = do_syscall(SYS_rmdir, pathname);
+//  if (auto e = syscall_error(ret); e)
+//		return e;
+
+// 	return 0;
+// }
+
+// int sys_socket(int domain, int type_and_flags, int proto, int *fd)
+// {
+// 	auto ret = do_syscall(SYS_socket, domain, type_and_flags, proto);
+// 	if (auto e = syscall_error(ret); e)
+//		return e;
+// 	*fd = int(ret);
+// 	return 0;
+// }
+
+// int sys_socketpair(int, int, int, int *)
+
+// int sys_bind(int fd, const struct sockaddr *addr_ptr, socklen_t addr_length)
+// {
+// 	auto ret = do_syscall(SYS_bind, fd, addr_ptr, addr_length);
+//  if (auto e = syscall_error(ret); e)
+//		return e;
+// 	return 0;
+// }
+
+// int sys_connect(int fd, const struct sockaddr *addr_ptr, socklen_t addr_length)
+// {
+// 	auto ret = do_syscall(SYS_connect, fd, addr_ptr, addr_length);
+// 	if (auto e = syscall_error(ret); e)
+//		return e;
+// 	return 0;
+// }
+
+// int sys_accept(int fd, int *newfd, struct sockaddr *addr_ptr, socklen_t *addr_length)
+// {
+// 	auto ret = do_syscall(SYS_accept, fd, addr_ptr, addr_length);
+// 	if (auto e = syscall_error(ret); e)
+//		return e;
+// 	*newfd = int(ret);
+// 	return 0;
+// }
+
+int sys_getsockopt(int fd, int layer, int number, void *__restrict buffer, socklen_t *__restrict size)
+{
+	(void)fd;
+	(void)size;
+	if (layer == SOL_SOCKET && number == SO_PEERCRED)
+	{
+		mlibc::infoLogger() << "mlibc: getsockopt() call with SOL_SOCKET and SO_PEERCRED is unimplemented" << frg::endlog;
+		*(int*)buffer = 0;
+		return 0;
+	}
+	else if (layer == SOL_SOCKET && number == SO_SNDBUF)
+	{
+		mlibc::infoLogger() << "mlibc: getsockopt() call with SOL_SOCKET and SO_SNDBUF is unimplemented" << frg::endlog;
+		*(int*)buffer = 4096;
+		return 0;
+	}
+	else if (layer == SOL_SOCKET && number == SO_TYPE)
+	{
+		mlibc::infoLogger() << "mlibc: getsockopt() call with SOL_SOCKET and SO_TYPE is unimplemented, hardcoding SOCK_STREAM" << frg::endlog;
+		*(int*)buffer = SOCK_STREAM;
+		return 0;
+	}
+	else if (layer == SOL_SOCKET && number == SO_ERROR)
+	{
+		mlibc::infoLogger() << "mlibc: getsockopt() call with SOL_SOCKET and SO_ERROR is unimplemented, hardcoding 0" << frg::endlog;
+		*(int*)buffer = 0;
+		return 0;
+	}
+	else if (layer == SOL_SOCKET && number == SO_KEEPALIVE)
+	{
+		mlibc::infoLogger() << "mlibc: getsockopt() call with SOL_SOCKET and SO_KEEPALIVE is unimplemented, hardcoding 0" << frg::endlog;
+		*(int*)buffer = 0;
+		return 0;
+	}
+	else mlibc::panicLogger() << "mlibc: Unexpected getsockopt() call, layer: " << layer << " number: " << number << frg::endlog;
+
+	return 0;
+}
+
+int sys_setsockopt(int fd, int layer, int number, const void *buffer, socklen_t size)
+{
+	(void)fd;
+	(void)buffer;
+	(void)size;
+	if (layer == SOL_SOCKET && number == SO_PASSCRED)
+	{
+		mlibc::infoLogger() << "mlibc: setsockopt(SO_PASSCRED) is not implemented correctly" << frg::endlog;
+		return 0;
+	}
+	else if (layer == SOL_SOCKET && number == SO_ATTACH_FILTER)
+	{
+		mlibc::infoLogger() << "mlibc: setsockopt(SO_ATTACH_FILTER) is not implemented correctly" << frg::endlog;
+		return 0;
+	}
+	else if (layer == SOL_SOCKET && number == SO_RCVBUFFORCE)
+	{
+		mlibc::infoLogger() << "mlibc: setsockopt(SO_RCVBUFFORCE) is not implemented correctly" << frg::endlog;
+		return 0;
+	}
+	else if (layer == SOL_SOCKET && number == SO_SNDBUF)
+	{
+		mlibc::infoLogger() << "mlibc: setsockopt() call with SOL_SOCKET and SO_SNDBUF is unimplemented" << frg::endlog;
+		return 0;
+	}
+	else if (layer == SOL_SOCKET && number == SO_KEEPALIVE)
+	{
+		mlibc::infoLogger() << "mlibc: setsockopt() call with SOL_SOCKET and SO_KEEPALIVE is unimplemented" << frg::endlog;
+		return 0;
+	}
+	else if (layer == SOL_SOCKET && number == SO_REUSEADDR)
+	{
+		mlibc::infoLogger() << "mlibc: setsockopt() call with SOL_SOCKET and SO_REUSEADDR is unimplemented" << frg::endlog;
+		return 0;
+	}
+	else if (layer == AF_NETLINK && number == SO_ACCEPTCONN)
+	{
+		mlibc::infoLogger() << "mlibc: setsockopt() call with AF_NETLINK and SO_ACCEPTCONN is unimplemented" << frg::endlog;
+		return 0;
+	}
+	else
+	{
+		mlibc::panicLogger() << "mlibc: Unexpected setsockopt() call, layer: " << layer << " number: " << number << frg::endlog;
+		sys_libc_panic();
+	}
+}
+
+// int sys_msg_recv(int sockfd, struct msghdr *hdr, int flags, ssize_t *length)
+// {
+// 	auto ret = do_syscall(SYS_recvmsg, sockfd, hdr, flags);
+// 	if (auto e = syscall_error(ret); e)
+//		return e;
+// 	*length = ssize_t(ret);
+// 	return 0;
+// }
+
+// int sys_peername(int fd, struct sockaddr *addr_ptr, socklen_t max_addr_length, socklen_t *actual_length)
+// {
+// 	auto ret = do_syscall(SYS_getpeername, fd, addr_ptr, &max_addr_length);
+// 	if (auto e = syscall_error(ret); e)
+//		return e;
+// 	*actual_length = max_addr_length;
+// 	return 0;
+// }
+
+// int sys_listen(int fd, int backlog)
+// {
+// 	auto ret = do_syscall(SYS_listen, fd, backlog);
+// 	if (auto e = syscall_error(ret); e)
+//		return e;
+// 	return 0;
+// }
+
+// int sys_inotify_create(int, int *)
+
+int sys_execve(const char *path, char *const argv[], char *const envp[])
+{
+	auto ret = do_syscall(SYS_execve, path, argv, envp);
+	if (auto e = syscall_error(ret); e)
+		return e;
+	return 0;
+}
+
+int sys_fcntl(int fd, int request, va_list args, int *result)
+{
+	auto ret = do_syscall(SYS_fcntl, fd, request, va_arg(args, uint64_t));
+	if (auto e = syscall_error(ret); e)
+		return e;
+	*result = int(ret);
+	return 0;
+}
+
+int sys_dup(int fd, int flags, int *newfd)
+{
+	(void)flags;
+	auto ret = do_syscall(SYS_dup, fd);
+	if (auto e = syscall_error(ret); e)
+		return e;
+	*newfd = int(ret);
+	return 0;
+}
+
+int sys_dup2(int fd, int flags, int newfd)
+{
+	auto ret = do_syscall(SYS_dup3, fd, newfd, flags);
+	if (auto e = syscall_error(ret); e)
+		return e;
+	return 0;
+}
+
+int sys_sigprocmask(int, const sigset_t *__restrict, sigset_t *__restrict)
+{
+	mlibc::infoLogger() << "mlibc: sys_sigprocmask() is a stub" << frg::endlog;
+	return 0;
+}
+
+int sys_sigaction(int, const struct sigaction *, struct sigaction *)
+{
+	mlibc::infoLogger() << "mlibc: sys_sigaction() is a stub" << frg::endlog;
+	return 0;
+}
+
+// int sys_signalfd_create(sigset_t, int, int *)
+
+int sys_waitpid(pid_t pid, int *status, int flags, struct rusage *ru, pid_t *ret_pid)
+{
+	if (ru != NULL)
+	{
+		mlibc::infoLogger() << "mlibc: struct rusage in sys_waitpid is unsupported" << frg::endlog;
+		return ENOSYS;
+	}
+
+	auto ret = do_syscall(SYS_wait4, pid, status, flags, ru);
+	if (auto e = syscall_error(ret); e)
+		return e;
+	*ret_pid = int(ret);
+	return 0;
+}
+
+// int sys_getgroups(size_t, const gid_t *, int *)
+
+// int sys_mount(const char *, const char *, const char *, unsigned long, const void *)
+
+// int sys_umount2(const char *, int)
+
+int sys_gethostname(char *buffer, size_t bufsize)
+{
+	struct utsname utsname;
+	if (int err = sys_uname(&utsname))
+		return err;
+	if (strlen(utsname.nodename) >= bufsize)
+		return ENAMETOOLONG;
+	strncpy(buffer, utsname.nodename, bufsize);
+	return 0;
+}
+
+// int sys_sethostname(const char *, size_t)
+
+// int sys_sleep(time_t *secs, long *nanos)
+// {
+// 	struct timespec time = { .tv_sec = *secs, .tv_nsec = *nanos };
+// 	struct timespec rem = { .tv_sec = 0, .tv_nsec = 0 };
+// 	auto ret = do_syscall(SYS_sleep, &time, &rem);
+// 	if (auto e = syscall_error(ret); e)
+//		return e;
+// 	*secs = rem.tv_sec;
+// 	*nanos = rem.tv_nsec;
+// 	return 0;
+// }
+
+int sys_getitimer(int, struct itimerval *)
+{
+	mlibc::infoLogger() << "mlibc: sys_getitimer() is unimplemented" << frg::endlog;
+	return ENOSYS;
+}
+
+int sys_setitimer(int, const struct itimerval *, struct itimerval *)
+{
+	mlibc::infoLogger() << "mlibc: sys_setitimer() is unimplemented" << frg::endlog;
+	return ENOSYS;
+}
+
+int sys_umask(mode_t mode, mode_t *old)
+{
+	auto ret = do_syscall(SYS_umask, mode);
+	*old = mode_t(ret);
+	return 0;
+}
+
+int sys_uname(struct utsname *buf)
+{
+	auto ret = do_syscall(SYS_uname, buf);
+	if (auto e = syscall_error(ret); e)
+		return e;
+	return 0;
+}
+
+int sys_fsync(int)
+{
+	mlibc::infoLogger() << "sys_fsync is a stub" << frg::endlog;
+	return 0;
+}
+
+
+int sys_getrlimit(int resource, struct rlimit *limit) STUB_ONLY(getrlimit)
+// {
+// 	auto ret = do_syscall(SYS_getrlimit, resource, limit);
+// 	if (auto e = syscall_error(ret); e)
+// 		return e;
+// 	return 0;
+// }
+
+// int sys_vm_protect(void *, size_t, int)
+
+#endif
+
+} // namespace mlibc
diff --git a/sysdeps/ilobilix/include/abi-bits/access.h b/sysdeps/ilobilix/include/abi-bits/access.h
new file mode 120000
index 00000000..cb839316
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/access.h
@@ -0,0 +1 @@
+../../../../abis/linux/access.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/auxv.h b/sysdeps/ilobilix/include/abi-bits/auxv.h
new file mode 120000
index 00000000..c43f8786
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/auxv.h
@@ -0,0 +1 @@
+../../../../abis/linux/auxv.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/blkcnt_t.h b/sysdeps/ilobilix/include/abi-bits/blkcnt_t.h
new file mode 120000
index 00000000..0b0ec270
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/blkcnt_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/blkcnt_t.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/blksize_t.h b/sysdeps/ilobilix/include/abi-bits/blksize_t.h
new file mode 120000
index 00000000..7dc8d7cf
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/blksize_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/blksize_t.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/clockid_t.h b/sysdeps/ilobilix/include/abi-bits/clockid_t.h
new file mode 120000
index 00000000..6a42da56
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/clockid_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/clockid_t.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/dev_t.h b/sysdeps/ilobilix/include/abi-bits/dev_t.h
new file mode 120000
index 00000000..bca881e9
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/dev_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/dev_t.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/epoll.h b/sysdeps/ilobilix/include/abi-bits/epoll.h
new file mode 120000
index 00000000..eb4b76dc
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/epoll.h
@@ -0,0 +1 @@
+../../../../abis/linux/epoll.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/errno.h b/sysdeps/ilobilix/include/abi-bits/errno.h
new file mode 120000
index 00000000..6e507def
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/errno.h
@@ -0,0 +1 @@
+../../../../abis/linux/errno.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/fcntl.h b/sysdeps/ilobilix/include/abi-bits/fcntl.h
new file mode 120000
index 00000000..463e2c95
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/fcntl.h
@@ -0,0 +1 @@
+../../../../abis/linux/fcntl.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/fsblkcnt_t.h b/sysdeps/ilobilix/include/abi-bits/fsblkcnt_t.h
new file mode 120000
index 00000000..898dfb2f
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/fsblkcnt_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/fsblkcnt_t.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/fsfilcnt_t.h b/sysdeps/ilobilix/include/abi-bits/fsfilcnt_t.h
new file mode 120000
index 00000000..791755c9
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/fsfilcnt_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/fsfilcnt_t.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/gid_t.h b/sysdeps/ilobilix/include/abi-bits/gid_t.h
new file mode 120000
index 00000000..6a772180
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/gid_t.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/gid_t.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/in.h b/sysdeps/ilobilix/include/abi-bits/in.h
new file mode 120000
index 00000000..418d1d5c
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/in.h
@@ -0,0 +1 @@
+../../../../abis/linux/in.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/ino_t.h b/sysdeps/ilobilix/include/abi-bits/ino_t.h
new file mode 120000
index 00000000..4c20aca2
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/ino_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/ino_t.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/inotify.h b/sysdeps/ilobilix/include/abi-bits/inotify.h
new file mode 120000
index 00000000..b5cb2823
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/inotify.h
@@ -0,0 +1 @@
+../../../../abis/linux/inotify.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/ioctls.h b/sysdeps/ilobilix/include/abi-bits/ioctls.h
new file mode 120000
index 00000000..595106b6
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/ioctls.h
@@ -0,0 +1 @@
+../../../../abis/linux/ioctls.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/limits.h b/sysdeps/ilobilix/include/abi-bits/limits.h
new file mode 120000
index 00000000..6c88db2e
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/limits.h
@@ -0,0 +1 @@
+../../../../abis/linux/limits.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/mode_t.h b/sysdeps/ilobilix/include/abi-bits/mode_t.h
new file mode 120000
index 00000000..5d78fdfc
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/mode_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/mode_t.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/mqueue.h b/sysdeps/ilobilix/include/abi-bits/mqueue.h
new file mode 120000
index 00000000..fa87b078
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/mqueue.h
@@ -0,0 +1 @@
+../../../../abis/linux/mqueue.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/nlink_t.h b/sysdeps/ilobilix/include/abi-bits/nlink_t.h
new file mode 120000
index 00000000..bb3b625c
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/nlink_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/nlink_t.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/packet.h b/sysdeps/ilobilix/include/abi-bits/packet.h
new file mode 120000
index 00000000..998ef1ab
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/packet.h
@@ -0,0 +1 @@
+../../../../abis/linux/packet.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/pid_t.h b/sysdeps/ilobilix/include/abi-bits/pid_t.h
new file mode 120000
index 00000000..baa90f6a
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/pid_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/pid_t.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/poll.h b/sysdeps/ilobilix/include/abi-bits/poll.h
new file mode 120000
index 00000000..8ea6a0a3
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/poll.h
@@ -0,0 +1 @@
+../../../../abis/linux/poll.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/ptrace.h b/sysdeps/ilobilix/include/abi-bits/ptrace.h
new file mode 120000
index 00000000..b2517b2c
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/ptrace.h
@@ -0,0 +1 @@
+../../../../abis/linux/ptrace.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/reboot.h b/sysdeps/ilobilix/include/abi-bits/reboot.h
new file mode 120000
index 00000000..77013a41
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/reboot.h
@@ -0,0 +1 @@
+../../../../abis/linux/reboot.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/resource.h b/sysdeps/ilobilix/include/abi-bits/resource.h
new file mode 120000
index 00000000..88d74025
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/resource.h
@@ -0,0 +1 @@
+../../../../abis/linux/resource.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/seek-whence.h b/sysdeps/ilobilix/include/abi-bits/seek-whence.h
new file mode 120000
index 00000000..df7bccf0
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/seek-whence.h
@@ -0,0 +1 @@
+../../../../abis/linux/seek-whence.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/shm.h b/sysdeps/ilobilix/include/abi-bits/shm.h
new file mode 120000
index 00000000..067d8c4f
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/shm.h
@@ -0,0 +1 @@
+../../../../abis/linux/shm.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/signal.h b/sysdeps/ilobilix/include/abi-bits/signal.h
new file mode 120000
index 00000000..4dcb0b7c
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/signal.h
@@ -0,0 +1 @@
+../../../../abis/linux/signal.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/socket.h b/sysdeps/ilobilix/include/abi-bits/socket.h
new file mode 120000
index 00000000..f1dc016e
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/socket.h
@@ -0,0 +1 @@
+../../../../abis/linux/socket.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/socklen_t.h b/sysdeps/ilobilix/include/abi-bits/socklen_t.h
new file mode 120000
index 00000000..41f3b11f
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/socklen_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/socklen_t.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/stat.h b/sysdeps/ilobilix/include/abi-bits/stat.h
new file mode 120000
index 00000000..1f63b41f
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/stat.h
@@ -0,0 +1 @@
+../../../../abis/linux/stat.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/statfs.h b/sysdeps/ilobilix/include/abi-bits/statfs.h
new file mode 120000
index 00000000..e3d202f5
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/statfs.h
@@ -0,0 +1 @@
+../../../../abis/linux/statfs.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/statvfs.h b/sysdeps/ilobilix/include/abi-bits/statvfs.h
new file mode 120000
index 00000000..1fc80c2a
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/statvfs.h
@@ -0,0 +1 @@
+../../../../abis/linux/statvfs.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/suseconds_t.h b/sysdeps/ilobilix/include/abi-bits/suseconds_t.h
new file mode 120000
index 00000000..9ed65977
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/suseconds_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/suseconds_t.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/termios.h b/sysdeps/ilobilix/include/abi-bits/termios.h
new file mode 120000
index 00000000..ee8f0b09
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/termios.h
@@ -0,0 +1 @@
+../../../../abis/linux/termios.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/time.h b/sysdeps/ilobilix/include/abi-bits/time.h
new file mode 120000
index 00000000..2a026257
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/time.h
@@ -0,0 +1 @@
+../../../../abis/linux/time.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/uid_t.h b/sysdeps/ilobilix/include/abi-bits/uid_t.h
new file mode 120000
index 00000000..b3067778
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/uid_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/uid_t.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/utsname.h b/sysdeps/ilobilix/include/abi-bits/utsname.h
new file mode 120000
index 00000000..b2857547
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/utsname.h
@@ -0,0 +1 @@
+../../../../abis/linux/utsname.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/vm-flags.h b/sysdeps/ilobilix/include/abi-bits/vm-flags.h
new file mode 120000
index 00000000..bbe258cf
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/vm-flags.h
@@ -0,0 +1 @@
+../../../../abis/linux/vm-flags.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/vt.h b/sysdeps/ilobilix/include/abi-bits/vt.h
new file mode 120000
index 00000000..5798a4ac
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/vt.h
@@ -0,0 +1 @@
+../../../../abis/linux/vt.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/wait.h b/sysdeps/ilobilix/include/abi-bits/wait.h
new file mode 120000
index 00000000..feb2840c
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/wait.h
@@ -0,0 +1 @@
+../../../../abis/linux/wait.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/xattr.h b/sysdeps/ilobilix/include/abi-bits/xattr.h
new file mode 120000
index 00000000..66412d70
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/xattr.h
@@ -0,0 +1 @@
+../../../../abis/linux/xattr.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/ilobilix/syscall.h b/sysdeps/ilobilix/include/ilobilix/syscall.h
new file mode 100644
index 00000000..a6eea190
--- /dev/null
+++ b/sysdeps/ilobilix/include/ilobilix/syscall.h
@@ -0,0 +1,158 @@
+#ifndef _ILOBILIX__SYSCALL_H
+#define _ILOBILIX__SYSCALL_H
+
+#include <stdint.h>
+
+#if defined(__x86_64__)
+
+#define SYS_read 0
+#define SYS_write 1
+#define SYS_open 2
+#define SYS_close 3
+#define SYS_stat 4
+#define SYS_fstat 5
+#define SYS_lstat 6
+#define SYS_lseek 8
+#define SYS_mmap 9
+#define SYS_munmap 11
+#define SYS_ioctl 16
+#define SYS_dup 32
+#define SYS_dup2 33
+#define SYS_getpid 39
+#define SYS_clone 56
+#define SYS_fork 57
+#define SYS_execve 59
+#define SYS_exit 60
+#define SYS_wait4 61
+#define SYS_uname 63
+#define SYS_fcntl 72
+#define SYS_getdents 78
+#define SYS_getcwd 79
+#define SYS_chdir 80
+#define SYS_fchdir 81
+#define SYS_link 86
+#define SYS_unlink 87
+#define SYS_readlink 89
+#define SYS_fchmod 91
+#define SYS_umask 95
+#define SYS_getppid 110
+#define SYS_arch_prctl 158
+#define SYS_getdents64 217
+#define SYS_openat 257
+#define SYS_fstatat 262
+#define SYS_unlinkat 263
+#define SYS_linkat 265
+#define SYS_readlinkat 267
+#define SYS_fchmodat 268
+#define SYS_dup3 292
+
+#ifdef __SYSCALL_USE_INT__
+#   define __SYSCALL__ "int $0x80"
+#else
+#   define __SYSCALL__ "syscall"
+#endif
+
+static inline uintptr_t __syscall0(uintptr_t n)
+{
+    uintptr_t ret;
+    asm volatile (__SYSCALL__ : "=a"(ret) : "a"(n) : "rcx", "r11", "memory");
+    return ret;
+}
+
+static inline uintptr_t __syscall1(uintptr_t n, uintptr_t a1)
+{
+    uintptr_t ret;
+    asm volatile (__SYSCALL__ : "=a"(ret) : "a"(n), "D"(a1) : "rcx", "r11", "memory");
+    return ret;
+}
+
+static inline uintptr_t __syscall2(uintptr_t n, uintptr_t a1, uintptr_t a2)
+{
+    uintptr_t ret;
+    asm volatile (__SYSCALL__ : "=a"(ret) : "a"(n), "D"(a1), "S"(a2) : "rcx", "r11", "memory");
+    return ret;
+}
+
+static inline uintptr_t __syscall3(uintptr_t n, uintptr_t a1, uintptr_t a2, uintptr_t a3)
+{
+    uintptr_t ret;
+    asm volatile (__SYSCALL__ : "=a"(ret) : "a"(n), "D"(a1), "S"(a2), "d"(a3) : "rcx", "r11", "memory");
+    return ret;
+}
+
+static inline uintptr_t __syscall4(uintptr_t n, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4)
+{
+    uintptr_t ret;
+    register uintptr_t r10 asm("r10") = a4;
+    asm volatile (__SYSCALL__ : "=a"(ret) : "a"(n), "D"(a1), "S"(a2), "d"(a3), "r"(r10): "rcx", "r11", "memory");
+    return ret;
+}
+
+static inline uintptr_t __syscall5(uintptr_t n, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4, uintptr_t a5)
+{
+    uintptr_t ret;
+    register uintptr_t r10 asm("r10") = a4;
+    register uintptr_t r8 asm("r8") = a5;
+    asm volatile (__SYSCALL__ : "=a"(ret) : "a"(n), "D"(a1), "S"(a2), "d"(a3), "r"(r10), "r"(r8) : "rcx", "r11", "memory");
+    return ret;
+}
+
+static inline uintptr_t __syscall6(uintptr_t n, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4, uintptr_t a5, uintptr_t a6)
+{
+    uintptr_t ret;
+    register uintptr_t r10 asm("r10") = a4;
+    register uintptr_t r8 asm("r8") = a5;
+    register uintptr_t r9 asm("r9") = a6;
+    asm volatile (__SYSCALL__ : "=a"(ret) : "a"(n), "D"(a1), "S"(a2), "d"(a3), "r"(r10), "r"(r8), "r"(r9) : "rcx", "r11", "memory");
+    return ret;
+}
+
+#undef __SYSCALL__
+
+#elif defined(__aarch64__)
+
+#define SYS_getcwd 17
+#define SYS_dup 23
+#define SYS_dup3 24
+#define SYS_fcntl 25
+#define SYS_ioctl 29
+#define SYS_unlinkat 35
+#define SYS_linkat 37
+#define SYS_chdir 49
+#define SYS_fchdir 50
+#define SYS_fchmod 52
+#define SYS_fchmodat 53
+#define SYS_openat 56
+#define SYS_close 57
+#define SYS_getdents64 61
+#define SYS_lseek 62
+#define SYS_read 63
+#define SYS_write 64
+#define SYS_readlinkat 78
+#define SYS_fstatat 79
+#define SYS_exit 93
+#define SYS_uname 160
+#define SYS_umask 166
+#define SYS_getpid 172
+#define SYS_getppid 173
+#define SYS_munmap 216
+#define SYS_clone 220
+#define SYS_execve 221
+#define SYS_mmap 222
+#define SYS_wait4 260
+
+static inline uintptr_t __syscall0(uintptr_t n) { return -1; }
+static inline uintptr_t __syscall1(uintptr_t n, uintptr_t a1) { return -1; }
+static inline uintptr_t __syscall2(uintptr_t n, uintptr_t a1, uintptr_t a2) { return -1; }
+static inline uintptr_t __syscall3(uintptr_t n, uintptr_t a1, uintptr_t a2, uintptr_t a3) { return -1; }
+static inline uintptr_t __syscall4(uintptr_t n, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4) { return -1; }
+static inline uintptr_t __syscall5(uintptr_t n, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4, uintptr_t a5) { return -1; }
+static inline uintptr_t __syscall6(uintptr_t n, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4, uintptr_t a5, uintptr_t a6) { return -1; }
+
+#endif
+
+#define GET_MACRO(_1,_2,_3,_4,_5,_6,_7,NAME,...) NAME
+#define __syscall(...) GET_MACRO(__VA_ARGS__, __syscall6, __syscall5, __syscall4, __syscall3, __syscall2, __syscall1, __syscall0)(__VA_ARGS__)
+#define syscall __syscall
+
+#endif
diff --git a/sysdeps/ilobilix/meson.build b/sysdeps/ilobilix/meson.build
new file mode 100644
index 00000000..00662560
--- /dev/null
+++ b/sysdeps/ilobilix/meson.build
@@ -0,0 +1,93 @@
+
+rtdl_dso_sources += files(
+	'generic/sysdeps.cpp'
+)
+
+libc_sources += files(
+	'generic/entry.cpp',
+	'generic/sysdeps.cpp'
+)
+
+if not no_headers
+	install_headers(
+		'include/abi-bits/auxv.h',
+		'include/abi-bits/seek-whence.h',
+		'include/abi-bits/vm-flags.h',
+		'include/abi-bits/errno.h',
+		'include/abi-bits/fcntl.h',
+		'include/abi-bits/in.h',
+		'include/abi-bits/stat.h',
+		'include/abi-bits/signal.h',
+		'include/abi-bits/reboot.h',
+		'include/abi-bits/resource.h',
+		'include/abi-bits/socket.h',
+		'include/abi-bits/termios.h',
+		'include/abi-bits/time.h',
+		'include/abi-bits/blkcnt_t.h',
+		'include/abi-bits/blksize_t.h',
+		'include/abi-bits/dev_t.h',
+		'include/abi-bits/gid_t.h',
+		'include/abi-bits/ino_t.h',
+		'include/abi-bits/mode_t.h',
+		'include/abi-bits/nlink_t.h',
+		'include/abi-bits/pid_t.h',
+		'include/abi-bits/uid_t.h',
+		'include/abi-bits/access.h',
+		'include/abi-bits/wait.h',
+		'include/abi-bits/limits.h',
+		'include/abi-bits/utsname.h',
+		'include/abi-bits/vt.h',
+		'include/abi-bits/ptrace.h',
+		'include/abi-bits/poll.h',
+		'include/abi-bits/epoll.h',
+		'include/abi-bits/packet.h',
+		'include/abi-bits/inotify.h',
+		'include/abi-bits/clockid_t.h',
+		'include/abi-bits/shm.h',
+		'include/abi-bits/mqueue.h',
+		'include/abi-bits/suseconds_t.h',
+		'include/abi-bits/fsfilcnt_t.h',
+		'include/abi-bits/fsblkcnt_t.h',
+		'include/abi-bits/socklen_t.h',
+		'include/abi-bits/statfs.h',
+		'include/abi-bits/statvfs.h',
+		'include/abi-bits/ioctls.h',
+		'include/abi-bits/xattr.h',
+		subdir: 'abi-bits'
+	)
+
+	install_headers(
+		'include/ilobilix/syscall.h',
+		subdir: 'ilobilix',
+	)
+endif
+
+if not headers_only
+	crt = custom_target('crt0',
+		build_by_default: true,
+		command: c_compiler.cmd_array() + ['-c', '-o', '@OUTPUT@', '@INPUT@'],
+		input: host_machine.cpu_family() / 'crt-src/crt0.S',
+		output: 'crt0.o',
+		install: true,
+		install_dir: get_option('libdir')
+	)
+
+	custom_target('crti',
+		build_by_default: true,
+		command: c_compiler.cmd_array() + ['-c', '-o', '@OUTPUT@', '@INPUT@'],
+		input: host_machine.cpu_family() / 'crt-src/crti.S',
+		output: 'crti.o',
+		install: true,
+		install_dir: get_option('libdir')
+	)
+
+	custom_target('crtn',
+		build_by_default: true,
+		command: c_compiler.cmd_array() + ['-c', '-o', '@OUTPUT@', '@INPUT@'],
+		input: host_machine.cpu_family() / 'crt-src/crtn.S',
+		output: 'crtn.o',
+		install: true,
+		install_dir: get_option('libdir')
+	)
+endif
+
diff --git a/sysdeps/ilobilix/x86_64/crt-src/crt0.S b/sysdeps/ilobilix/x86_64/crt-src/crt0.S
new file mode 100644
index 00000000..4a5cf860
--- /dev/null
+++ b/sysdeps/ilobilix/x86_64/crt-src/crt0.S
@@ -0,0 +1,8 @@
+.section .text
+.global _start
+_start:
+    mov %rsp, %rdi
+    mov $main, %rsi
+    call __mlibc_entry
+.section .note.GNU-stack,"",%progbits
+
diff --git a/sysdeps/ilobilix/x86_64/crt-src/crti.S b/sysdeps/ilobilix/x86_64/crt-src/crti.S
new file mode 100644
index 00000000..911b078d
--- /dev/null
+++ b/sysdeps/ilobilix/x86_64/crt-src/crti.S
@@ -0,0 +1,11 @@
+.section .init
+.global _init
+_init:
+	push %rax
+
+.section .fini
+.global _fini
+_fini:
+	push %rax
+.section .note.GNU-stack,"",%progbits
+
diff --git a/sysdeps/ilobilix/x86_64/crt-src/crtn.S b/sysdeps/ilobilix/x86_64/crt-src/crtn.S
new file mode 100644
index 00000000..0187e50f
--- /dev/null
+++ b/sysdeps/ilobilix/x86_64/crt-src/crtn.S
@@ -0,0 +1,9 @@
+.section .init
+	pop %rax
+	ret
+
+.section .fini
+	pop %rax
+	ret
+.section .note.GNU-stack,"",%progbits
+
-- 
2.37.2

