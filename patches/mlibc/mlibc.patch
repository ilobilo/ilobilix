From cdbbbf866620735890eba11c929e9cdd2295e786 Mon Sep 17 00:00:00 2001
From: ilobilo <ilia.chachanidze35@gmail.com>
Date: Wed, 4 Jan 2023 20:17:36 +0400
Subject: Add wip ilobilix sysdeps

---
 meson.build                                   |   4 +
 sysdeps/ilobilix/aarch64/crt-src/crt0.S       |   9 +
 sysdeps/ilobilix/aarch64/crt-src/crti.S       |  13 +
 sysdeps/ilobilix/aarch64/crt-src/crtn.S       |   9 +
 sysdeps/ilobilix/generic/entry.cpp            |  37 +
 sysdeps/ilobilix/generic/sysdeps.cpp          | 823 ++++++++++++++++++
 sysdeps/ilobilix/include/abi-bits/access.h    |   1 +
 sysdeps/ilobilix/include/abi-bits/auxv.h      |   1 +
 sysdeps/ilobilix/include/abi-bits/blkcnt_t.h  |   1 +
 sysdeps/ilobilix/include/abi-bits/blksize_t.h |   1 +
 sysdeps/ilobilix/include/abi-bits/clockid_t.h |   1 +
 sysdeps/ilobilix/include/abi-bits/dev_t.h     |   1 +
 sysdeps/ilobilix/include/abi-bits/epoll.h     |   1 +
 sysdeps/ilobilix/include/abi-bits/errno.h     |   1 +
 sysdeps/ilobilix/include/abi-bits/fcntl.h     |   1 +
 .../ilobilix/include/abi-bits/fsblkcnt_t.h    |   1 +
 .../ilobilix/include/abi-bits/fsfilcnt_t.h    |   1 +
 sysdeps/ilobilix/include/abi-bits/gid_t.h     |   1 +
 sysdeps/ilobilix/include/abi-bits/in.h        |   1 +
 sysdeps/ilobilix/include/abi-bits/ino_t.h     |   1 +
 sysdeps/ilobilix/include/abi-bits/inotify.h   |   1 +
 sysdeps/ilobilix/include/abi-bits/ioctls.h    |   1 +
 sysdeps/ilobilix/include/abi-bits/limits.h    |   1 +
 sysdeps/ilobilix/include/abi-bits/mode_t.h    |   1 +
 sysdeps/ilobilix/include/abi-bits/mqueue.h    |   1 +
 sysdeps/ilobilix/include/abi-bits/nlink_t.h   |   1 +
 sysdeps/ilobilix/include/abi-bits/packet.h    |   1 +
 sysdeps/ilobilix/include/abi-bits/pid_t.h     |   1 +
 sysdeps/ilobilix/include/abi-bits/poll.h      |   1 +
 sysdeps/ilobilix/include/abi-bits/ptrace.h    |   1 +
 sysdeps/ilobilix/include/abi-bits/reboot.h    |   1 +
 sysdeps/ilobilix/include/abi-bits/resource.h  |   1 +
 .../ilobilix/include/abi-bits/seek-whence.h   |   1 +
 sysdeps/ilobilix/include/abi-bits/shm.h       |   1 +
 sysdeps/ilobilix/include/abi-bits/signal.h    |   1 +
 sysdeps/ilobilix/include/abi-bits/socket.h    |   1 +
 sysdeps/ilobilix/include/abi-bits/socklen_t.h |   1 +
 sysdeps/ilobilix/include/abi-bits/stat.h      |   1 +
 sysdeps/ilobilix/include/abi-bits/statfs.h    |   1 +
 sysdeps/ilobilix/include/abi-bits/statvfs.h   |   1 +
 .../ilobilix/include/abi-bits/suseconds_t.h   |   1 +
 sysdeps/ilobilix/include/abi-bits/termios.h   |   1 +
 sysdeps/ilobilix/include/abi-bits/time.h      |   1 +
 sysdeps/ilobilix/include/abi-bits/uid_t.h     |   1 +
 sysdeps/ilobilix/include/abi-bits/utsname.h   |   1 +
 sysdeps/ilobilix/include/abi-bits/vm-flags.h  |   1 +
 sysdeps/ilobilix/include/abi-bits/wait.h      |   1 +
 sysdeps/ilobilix/include/abi-bits/xattr.h     |   1 +
 sysdeps/ilobilix/include/ilobilix/syscall.h   | 144 +++
 sysdeps/ilobilix/meson.build                  |  92 ++
 sysdeps/ilobilix/x86_64/crt-src/crt0.S        |   8 +
 sysdeps/ilobilix/x86_64/crt-src/crti.S        |  11 +
 sysdeps/ilobilix/x86_64/crt-src/crtn.S        |   9 +
 53 files changed, 1201 insertions(+)
 create mode 100644 sysdeps/ilobilix/aarch64/crt-src/crt0.S
 create mode 100644 sysdeps/ilobilix/aarch64/crt-src/crti.S
 create mode 100644 sysdeps/ilobilix/aarch64/crt-src/crtn.S
 create mode 100644 sysdeps/ilobilix/generic/entry.cpp
 create mode 100644 sysdeps/ilobilix/generic/sysdeps.cpp
 create mode 120000 sysdeps/ilobilix/include/abi-bits/access.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/auxv.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/blkcnt_t.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/blksize_t.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/clockid_t.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/dev_t.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/epoll.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/errno.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/fcntl.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/fsblkcnt_t.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/fsfilcnt_t.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/gid_t.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/in.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/ino_t.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/inotify.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/ioctls.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/limits.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/mode_t.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/mqueue.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/nlink_t.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/packet.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/pid_t.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/poll.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/ptrace.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/reboot.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/resource.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/seek-whence.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/shm.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/signal.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/socket.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/socklen_t.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/stat.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/statfs.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/statvfs.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/suseconds_t.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/termios.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/time.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/uid_t.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/utsname.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/vm-flags.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/wait.h
 create mode 120000 sysdeps/ilobilix/include/abi-bits/xattr.h
 create mode 100644 sysdeps/ilobilix/include/ilobilix/syscall.h
 create mode 100644 sysdeps/ilobilix/meson.build
 create mode 100644 sysdeps/ilobilix/x86_64/crt-src/crt0.S
 create mode 100644 sysdeps/ilobilix/x86_64/crt-src/crti.S
 create mode 100644 sysdeps/ilobilix/x86_64/crt-src/crtn.S

diff --git a/meson.build b/meson.build
index a8cd3fec..5d26dd4c 100644
--- a/meson.build
+++ b/meson.build
@@ -135,6 +135,10 @@ elif host_machine.system() == 'lyre'
 	rtdl_include_dirs += include_directories('sysdeps/lyre/include')
 	libc_include_dirs += include_directories('sysdeps/lyre/include')
 	subdir('sysdeps/lyre')
+elif host_machine.system() == 'ilobilix'
+	rtdl_include_dirs += include_directories('sysdeps/ilobilix/include')
+	libc_include_dirs += include_directories('sysdeps/ilobilix/include')
+	subdir('sysdeps/ilobilix')
 elif host_machine.system() == 'lemon'
 	rtdl_include_dirs += include_directories('sysdeps/lemon/include')
 	libc_include_dirs += include_directories('sysdeps/lemon/include')
diff --git a/sysdeps/ilobilix/aarch64/crt-src/crt0.S b/sysdeps/ilobilix/aarch64/crt-src/crt0.S
new file mode 100644
index 00000000..91170a76
--- /dev/null
+++ b/sysdeps/ilobilix/aarch64/crt-src/crt0.S
@@ -0,0 +1,9 @@
+.section .text
+.global _start
+_start:
+	adrp x0, main
+	add x0, x0, :lo12:main
+	bl __mlibc_entry
+
+.section .note.GNU-stack,"",%progbits
+
diff --git a/sysdeps/ilobilix/aarch64/crt-src/crti.S b/sysdeps/ilobilix/aarch64/crt-src/crti.S
new file mode 100644
index 00000000..0f5ca0f1
--- /dev/null
+++ b/sysdeps/ilobilix/aarch64/crt-src/crti.S
@@ -0,0 +1,13 @@
+.section .init
+.global _init
+_init:
+	stp x29, x30, [sp, -16]!
+	mov x29, sp
+
+.section .fini
+.global _fini
+_fini:
+	stp x29, x30, [sp, -16]!
+	mov x29, sp
+.section .note.GNU-stack,"",%progbits
+
diff --git a/sysdeps/ilobilix/aarch64/crt-src/crtn.S b/sysdeps/ilobilix/aarch64/crt-src/crtn.S
new file mode 100644
index 00000000..cd95321a
--- /dev/null
+++ b/sysdeps/ilobilix/aarch64/crt-src/crtn.S
@@ -0,0 +1,9 @@
+.section .init
+	ldp x29, x30, [sp], #16
+	ret
+
+.section .fini
+	ldp x29, x30, [sp], #16
+	ret
+.section .note.GNU-stack,"",%progbits
+
diff --git a/sysdeps/ilobilix/generic/entry.cpp b/sysdeps/ilobilix/generic/entry.cpp
new file mode 100644
index 00000000..62b1c3cb
--- /dev/null
+++ b/sysdeps/ilobilix/generic/entry.cpp
@@ -0,0 +1,37 @@
+#include <mlibc/elf/startup.h>
+#include <ilobilix/syscall.h>
+#include <stdint.h>
+#include <stdlib.h>
+
+// defined by the POSIX library
+void __mlibc_initLocale();
+
+extern "C" uintptr_t *__dlapi_entrystack();
+extern "C" void __dlapi_enter(uintptr_t *);
+
+extern char **environ;
+static mlibc::exec_stack_data __mlibc_stack_data;
+
+struct LibraryGuard
+{
+	LibraryGuard();
+};
+
+static LibraryGuard guard;
+
+LibraryGuard::LibraryGuard()
+{
+	__mlibc_initLocale();
+
+	// Parse the exec() stack.
+	mlibc::parse_exec_stack(__dlapi_entrystack(), &__mlibc_stack_data);
+	mlibc::set_startup_data(__mlibc_stack_data.argc, __mlibc_stack_data.argv, __mlibc_stack_data.envp);
+}
+
+extern "C" void __mlibc_entry(uintptr_t *entry_stack, int (*main_fn)(int argc, char *argv[], char *env[]))
+{
+	__dlapi_enter(entry_stack);
+	auto result = main_fn(__mlibc_stack_data.argc, __mlibc_stack_data.argv, environ);
+	exit(result);
+}
+
diff --git a/sysdeps/ilobilix/generic/sysdeps.cpp b/sysdeps/ilobilix/generic/sysdeps.cpp
new file mode 100644
index 00000000..0ad69d83
--- /dev/null
+++ b/sysdeps/ilobilix/generic/sysdeps.cpp
@@ -0,0 +1,823 @@
+#include <bits/ensure.h>
+#include <mlibc/allocator.hpp>
+#include <mlibc/debug.hpp>
+#include <mlibc/all-sysdeps.hpp>
+#include <errno.h>
+#include <dirent.h>
+#include <fcntl.h>
+#include <limits.h>
+#include <asm/ioctls.h>
+#include <stdlib.h>
+#include <abi-bits/fcntl.h>
+#include <ilobilix/syscall.h>
+#include <frg/hash.hpp>
+#include <frg/hash_map.hpp>
+
+#define STUB_ONLY(name)                               \
+{                                                     \
+	sys_libc_log("mlibc: sys_" #name "() is a stub"); \
+	return 0;                                         \
+}
+
+namespace mlibc {
+
+uintptr_t __do_syscall(uintptr_t n, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4, uintptr_t a5, uintptr_t a6)
+{
+	return __syscall(n, a1, a2, a3, a4, a5, a6);
+}
+
+uintptr_t __do_syscall(uintptr_t n, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4, uintptr_t a5)
+{
+	return __syscall(n, a1, a2, a3, a4, a5);
+}
+
+uintptr_t __do_syscall(uintptr_t n, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4)
+{
+	return __syscall(n, a1, a2, a3, a4);
+}
+
+uintptr_t __do_syscall(uintptr_t n, uintptr_t a1, uintptr_t a2, uintptr_t a3)
+{
+	return __syscall(n, a1, a2, a3);
+}
+
+uintptr_t __do_syscall(uintptr_t n, uintptr_t a1, uintptr_t a2)
+{
+	return __syscall(n, a1, a2);
+}
+
+uintptr_t __do_syscall(uintptr_t n, uintptr_t a1)
+{
+	return __syscall(n, a1);
+}
+
+uintptr_t __do_syscall(uintptr_t n)
+{
+	return __syscall(n);
+}
+
+template<typename ...Args>
+requires (sizeof...(Args) > 0 && sizeof...(Args) <= 7)
+uintptr_t do_syscall(Args &&...args)
+{
+	return __do_syscall(uintptr_t(args)...);
+}
+
+inline int syscall_error(intptr_t ret)
+{
+	auto v = static_cast<intptr_t>(ret);
+	if(static_cast<uintptr_t>(v) > -4096UL)
+		return -v;
+	return 0;
+}
+
+void sys_libc_log(const char *message)
+{
+	size_t n = 0;
+	while(message[n])
+		n++;
+	do_syscall(SYS_write, 2, message, n);
+	char lf = '\n';
+	do_syscall(SYS_write, 2, &lf, 1);
+}
+
+void sys_libc_panic()
+{
+	sys_libc_log("\nMLIBC PANIC\n");
+	sys_exit(1);
+	__builtin_unreachable();
+}
+
+void sys_exit(int status)
+{
+	do_syscall(SYS_exit, status);
+	__builtin_unreachable();
+}
+
+int sys_tcb_set(void *pointer)
+{
+#if defined(__x86_64__)
+	do_syscall(SYS_arch_prctl, 0x1002 /* ARCH_SET_FS */, pointer);
+#elif defined (__aarch64__)
+	uintptr_t thread_data = reinterpret_cast<uintptr_t>(pointer) + sizeof(Tcb) - 0x10;
+	asm volatile ("msr tpidr_el0, %0" :: "r"(thread_data));
+#else
+#	error "Missing architecture specific code."
+#endif
+	return 0;
+}
+
+int sys_futex_wait(int *pointer, int expected, const struct timespec *time) STUB_ONLY(futex_wait)
+// {
+// 	return do_syscall(SYS_futex_wait, pointer, expected, time);
+// }
+
+int sys_futex_wake(int *pointer) STUB_ONLY(futex_wake)
+// {
+// 	uintptr_t ret = do_syscall(SYS_futex_wake, pointer);
+
+// 	if (auto e = syscall_error(ret); e)
+// 		return e;
+
+// 	int num_woken = ret;
+
+// 	__ensure(num_woken >= 0 && num_woken <= 1);
+// 	return num_woken;
+// }
+
+int sys_openat(int dirfd, const char *path, int flags, mode_t mode, int *fd)
+{
+	uintptr_t ret = do_syscall(SYS_openat, dirfd, path, flags, mode);
+
+	if (auto e = syscall_error(ret); e)
+		return e;
+
+	*fd = int(ret);
+	return 0;
+}
+
+int sys_open(const char *path, int flags, mode_t mode, int *fd)
+{
+	return sys_openat(AT_FDCWD, path, flags, mode, fd);
+}
+
+#ifndef MLIBC_BUILDING_RTDL
+struct ReadDirState
+{
+	size_t offset;
+	size_t capacity;
+	void *buffer;
+};
+
+static frg::hash_map<int, ReadDirState *, frg::hash<int>, MemoryAllocator> open_dirs { frg::hash<int> { }, getAllocator() };
+#endif
+
+int sys_close(int fd)
+{
+	uintptr_t ret = do_syscall(SYS_close, fd);
+	if (auto e = syscall_error(ret); e)
+		return e;
+
+#ifndef MLIBC_BUILDING_RTDL
+	open_dirs.remove(fd);
+#endif
+	return 0;
+}
+
+int sys_seek(int fd, off_t offset, int whence, off_t *new_offset)
+{
+	uintptr_t ret = do_syscall(SYS_lseek, fd, offset, whence);
+	if (auto e = syscall_error(ret); e)
+		return e;
+
+	*new_offset = off_t(ret);
+	return 0;
+}
+
+int sys_read(int fd, void *buf, size_t count, ssize_t *bytes_read)
+{
+	uintptr_t ret = do_syscall(SYS_read, fd, buf, count);
+	if (auto e = syscall_error(ret); e)
+		return e;
+
+	*bytes_read = ssize_t(ret);
+	return 0;
+}
+
+int sys_vm_map(void *hint, size_t size, int prot, int flags, int fd, off_t offset, void **window)
+{
+	uintptr_t ret = do_syscall(SYS_mmap, hint, size, prot, flags, fd, offset);
+	if (auto e = syscall_error(ret); e)
+		return e;
+
+	*window = (void*)ret;
+	return 0;
+}
+
+int sys_vm_unmap(void *pointer, size_t size)
+{
+	uintptr_t ret = do_syscall(SYS_munmap, pointer, size);
+	if (auto e = syscall_error(ret); e)
+		return e;
+	return 0;
+}
+
+int sys_anon_allocate(size_t size, void **pointer)
+{
+	return sys_vm_map(NULL, size, PROT_READ | PROT_WRITE, MAP_ANONYMOUS, -1, 0, pointer);
+}
+
+int sys_anon_free(void *pointer, size_t size)
+{
+	return sys_vm_unmap(pointer, size);
+}
+
+// All remaining functions are disabled in ldso.
+#ifndef MLIBC_BUILDING_RTDL
+
+// int sys_kill(pid_t, int)
+
+int sys_tcgetattr(int fd, struct termios *attr)
+{
+	int ret;
+	if (int r = sys_ioctl(fd, TCGETS, attr, &ret) != 0)
+		return r;
+
+	return 0;
+}
+
+int sys_tcsetattr(int fd, int optional_action, const struct termios *attr)
+{
+	int ret;
+	switch (optional_action)
+	{
+		case TCSANOW:
+			optional_action = TCSETS;
+			break;
+		case TCSADRAIN:
+			optional_action = TCSETSW;
+			break;
+		case TCSAFLUSH:
+			optional_action = TCSETSF;
+			break;
+		default:
+			__ensure(!"Unsupported tcsetattr");
+	}
+
+	if (int r = sys_ioctl(fd, optional_action, (void *)attr, &ret) != 0)
+		return r;
+
+	return 0;
+}
+
+// int sys_timerfd_create(int, int *)
+
+int sys_ioctl(int fd, unsigned long request, void *arg, int *result)
+{
+	uintptr_t ret = do_syscall(SYS_ioctl, fd, request, arg);
+	if (auto e = syscall_error(ret); e)
+		return e;
+
+	*result = int(ret);
+	return 0;
+}
+
+int sys_isatty(int fd)
+{
+	struct winsize ws;
+	int ret;
+
+	if (!sys_ioctl(fd, TIOCGWINSZ, &ws, &ret))
+		return 0;
+
+	return ENOTTY;
+}
+
+gid_t sys_getgid() STUB_ONLY(getgid)
+gid_t sys_getegid() STUB_ONLY(getegid)
+uid_t sys_getuid() STUB_ONLY(getuid)
+uid_t sys_geteuid() STUB_ONLY(geteuid)
+pid_t sys_getpid()
+{
+	return pid_t(do_syscall(SYS_getpid));
+}
+pid_t sys_gettid() STUB_ONLY(gettid)
+pid_t sys_getppid()
+{
+	return pid_t(do_syscall(SYS_getppid));
+}
+pid_t sys_getpgid(pid_t pid, pid_t *pgid) STUB_ONLY(getpgid)
+pid_t sys_getsid(pid_t pid, pid_t *sid) STUB_ONLY(getsid)
+
+int sys_setpgid(pid_t pid, pid_t pgid) STUB_ONLY(setpgid)
+int sys_setuid(uid_t uid) STUB_ONLY(setuid)
+int sys_seteuid(uid_t euid) STUB_ONLY(seteuid)
+int sys_setgid(gid_t gid) STUB_ONLY(setgid)
+int sys_setegid(gid_t egid) STUB_ONLY(setegid)
+
+// TODO
+int sys_ttyname(int, char *, size_t)
+{
+	return ENOSYS;
+}
+
+int sys_clock_get(int clock, time_t *secs, long *nanos) STUB_ONLY(clock_get)
+// {
+// 	struct timespec buf;
+// 	uintptr_t ret = do_syscall(SYS_getclock, clock, &buf);
+// 	if (auto e = syscall_error(ret); e)
+//		return e;
+
+// 	*secs = buf.tv_sec;
+// 	*nanos = buf.tv_nsec;
+// 	return 0;
+// }
+
+int sys_getcwd(char *buffer, size_t size)
+{
+	uintptr_t ret = do_syscall(SYS_getcwd, buffer, size);
+	if (auto e = syscall_error(ret); e)
+		return e;
+
+	return 0;
+}
+
+int sys_stat(fsfd_target fsfdt, int fd, const char *path, int flags, struct stat *statbuf)
+{
+	uintptr_t ret = 0;
+	switch (fsfdt)
+	{
+		case fsfd_target::fd:
+			ret = do_syscall(SYS_fstatat, fd, "", statbuf, flags | AT_EMPTY_PATH);
+			break;
+		case fsfd_target::path:
+			ret = do_syscall(SYS_fstatat, AT_FDCWD, path, statbuf, flags);
+			break;
+		case fsfd_target::fd_path:
+			ret = do_syscall(SYS_fstatat, fd, path, statbuf, flags);
+			break;
+		default:
+			__ensure(!"sys_stat: Invalid fsfdt");
+			__builtin_unreachable();
+	}
+	if (auto e = syscall_error(ret); e)
+		return e;
+	return 0;
+}
+
+int sys_faccessat(int dirfd, const char *pathname, int mode, int flags)
+{
+	(void)flags;
+	struct stat buf;
+	if (int r = sys_stat(fsfd_target::fd_path, dirfd, pathname, mode & AT_SYMLINK_FOLLOW, &buf))
+		return r;
+
+	return 0;
+}
+
+int sys_access(const char *path, int mode)
+{
+	return sys_faccessat(AT_FDCWD, path, mode, 0);
+}
+
+int sys_open_dir(const char *path, int *handle)
+{
+	return sys_openat(AT_FDCWD, path, O_DIRECTORY, 0, handle);
+}
+
+static ReadDirState *get_dir_state(int fdnum)
+{
+	ReadDirState *result;
+	if (auto value = open_dirs.get(fdnum))
+		result = *value;
+	else
+	{
+		result = (ReadDirState *)malloc(sizeof(ReadDirState));
+		result->offset = 0;
+		result->capacity = 1024;
+		result->buffer = malloc(result->capacity);
+		open_dirs.insert(fdnum, result);
+	}
+	return result;
+}
+
+// int sys_read_entries(int fdnum, void *buffer, size_t max_size, size_t *bytes_read)
+// {
+// 	ReadDirState *state = get_dir_state(fdnum);
+
+// retry:
+// 	uintptr_t ret = do_syscall(SYS_readdir, fdnum, state->buffer, &state->capacity);
+//  if (auto e = syscall_error(ret); e)
+//  {
+// 		if (e == ENOBUFS)
+//      {
+// 			state->buffer = realloc(state->buffer, state->capacity);
+// 			goto retry;
+// 		}
+//      else return e;
+// 	}
+
+// 	size_t offset = 0;
+// 	while (offset < max_size)
+//  {
+// 		struct dirent *ent = (struct dirent *)((char *)state->buffer + state->offset);
+// 		if (ent->d_reclen == 0)
+// 			break;
+
+// 		if (offset + ent->d_reclen >= max_size)
+// 			break;
+
+// 		memcpy((char *)buffer + offset, ent, ent->d_reclen);
+// 		offset += ent->d_reclen;
+// 		state->offset += ent->d_reclen;
+// 	}
+
+// 	*bytes_read = offset;
+// 	return 0;
+// }
+
+// int sys_pipe(int *fds, int flags)
+// {
+// 	uintptr_t ret = do_syscall(SYS_pipe, fds, flags);
+// 	if (auto e = syscall_error(ret); e)
+//		return e;
+// 	return 0;
+// }
+
+// int sys_chdir(const char *path)
+// {
+// 	uintptr_t ret = do_syscall(SYS_chdir, path);
+// 	if (auto e = syscall_error(ret); e)
+//		return e;
+// 	return 0;
+// }
+
+// int sys_mkdir(const char *path, mode_t mode)
+// {
+// 	return sys_mkdirat(AT_FDCWD, path, mode);
+// }
+
+// int sys_mkdirat(int dirfd, const char *path, mode_t mode)
+// {
+// 	uintptr_t ret = do_syscall(SYS_mkdirat, dirfd, path, mode);
+// 	if (auto e = syscall_error(ret); e)
+//		return e;
+// 	return 0;
+// }
+
+int sys_write(int fd, const void *buf, size_t count, ssize_t *bytes_written)
+{
+	uintptr_t ret = do_syscall(SYS_write, fd, buf, count);
+	if (auto e = syscall_error(ret); e)
+		return e;
+
+	*bytes_written = ssize_t(ret);
+	return 0;
+}
+
+int sys_readlink(const char *path, void *data, size_t max_size, ssize_t *length)
+{
+	uintptr_t ret = do_syscall(SYS_readlinkat, AT_FDCWD, path, data, max_size);
+	if (auto e = syscall_error(ret); e)
+		return e;
+
+	*length = ssize_t(ret);
+	return 0;
+}
+
+int sys_link(const char *old_path, const char *new_path)
+{
+	return sys_linkat(AT_FDCWD, old_path, AT_FDCWD, new_path, 0);
+}
+
+int sys_linkat(int olddirfd, const char *old_path, int newdirfd, const char *new_path, int flags)
+{
+	uintptr_t ret = do_syscall(SYS_linkat, olddirfd, old_path, newdirfd, new_path, flags);
+	if (auto e = syscall_error(ret); e)
+		return e;
+
+	return 0;
+}
+
+int sys_unlinkat(int fd, const char *path, int flags)
+{
+	uintptr_t ret = do_syscall(SYS_unlinkat, fd, path, flags);
+	if (auto e = syscall_error(ret); e)
+		return e;
+
+	return 0;
+}
+
+int sys_fchmodat(int fd, const char *pathname, mode_t mode, int flags)
+{
+	uintptr_t ret = do_syscall(SYS_fchmodat, fd, pathname, mode, flags);
+	if (auto e = syscall_error(ret); e)
+		return e;
+
+	return 0;
+}
+
+int sys_fchmod(int fd, mode_t mode)
+{
+	return sys_fchmodat(fd, "", mode, AT_EMPTY_PATH);
+}
+
+int sys_chmod(const char *pathname, mode_t mode)
+{
+	return sys_fchmodat(AT_FDCWD, pathname, mode, 0);
+}
+
+// int sys_rmdir(const char *pathname)
+// {
+// 	uintptr_t ret = do_syscall(SYS_rmdir, pathname);
+//  if (auto e = syscall_error(ret); e)
+//		return e;
+
+// 	return 0;
+// }
+
+// int sys_socket(int domain, int type_and_flags, int proto, int *fd)
+// {
+// 	uintptr_t ret = do_syscall(SYS_socket, domain, type_and_flags, proto);
+// 	if (auto e = syscall_error(ret); e)
+//		return e;
+// 	*fd = int(ret);
+// 	return 0;
+// }
+
+// int sys_socketpair(int, int, int, int *)
+
+// int sys_bind(int fd, const struct sockaddr *addr_ptr, socklen_t addr_length)
+// {
+// 	uintptr_t ret = do_syscall(SYS_bind, fd, addr_ptr, addr_length);
+//  if (auto e = syscall_error(ret); e)
+//		return e;
+// 	return 0;
+// }
+
+// int sys_connect(int fd, const struct sockaddr *addr_ptr, socklen_t addr_length)
+// {
+// 	uintptr_t ret = do_syscall(SYS_connect, fd, addr_ptr, addr_length);
+// 	if (auto e = syscall_error(ret); e)
+//		return e;
+// 	return 0;
+// }
+
+// int sys_accept(int fd, int *newfd, struct sockaddr *addr_ptr, socklen_t *addr_length)
+// {
+// 	uintptr_t ret = do_syscall(SYS_accept, fd, addr_ptr, addr_length);
+// 	if (auto e = syscall_error(ret); e)
+//		return e;
+// 	*newfd = int(ret);
+// 	return 0;
+// }
+
+int sys_getsockopt(int fd, int layer, int number, void *__restrict buffer, socklen_t *__restrict size)
+{
+	(void)fd;
+	(void)size;
+	if (layer == SOL_SOCKET && number == SO_PEERCRED)
+	{
+		mlibc::infoLogger() << "mlibc: getsockopt() call with SOL_SOCKET and SO_PEERCRED is unimplemented" << frg::endlog;
+		*(int*)buffer = 0;
+		return 0;
+	}
+	else if (layer == SOL_SOCKET && number == SO_SNDBUF)
+	{
+		mlibc::infoLogger() << "mlibc: getsockopt() call with SOL_SOCKET and SO_SNDBUF is unimplemented" << frg::endlog;
+		*(int*)buffer = 4096;
+		return 0;
+	}
+	else if (layer == SOL_SOCKET && number == SO_TYPE)
+	{
+		mlibc::infoLogger() << "mlibc: getsockopt() call with SOL_SOCKET and SO_TYPE is unimplemented, hardcoding SOCK_STREAM" << frg::endlog;
+		*(int*)buffer = SOCK_STREAM;
+		return 0;
+	}
+	else if (layer == SOL_SOCKET && number == SO_ERROR)
+	{
+		mlibc::infoLogger() << "mlibc: getsockopt() call with SOL_SOCKET and SO_ERROR is unimplemented, hardcoding 0" << frg::endlog;
+		*(int*)buffer = 0;
+		return 0;
+	}
+	else if (layer == SOL_SOCKET && number == SO_KEEPALIVE)
+	{
+		mlibc::infoLogger() << "mlibc: getsockopt() call with SOL_SOCKET and SO_KEEPALIVE is unimplemented, hardcoding 0" << frg::endlog;
+		*(int*)buffer = 0;
+		return 0;
+	}
+	else mlibc::panicLogger() << "mlibc: Unexpected getsockopt() call, layer: " << layer << " number: " << number << frg::endlog;
+
+	return 0;
+}
+
+int sys_setsockopt(int fd, int layer, int number, const void *buffer, socklen_t size)
+{
+	(void)fd;
+	(void)buffer;
+	(void)size;
+	if (layer == SOL_SOCKET && number == SO_PASSCRED)
+	{
+		mlibc::infoLogger() << "mlibc: setsockopt(SO_PASSCRED) is not implemented correctly" << frg::endlog;
+		return 0;
+	}
+	else if (layer == SOL_SOCKET && number == SO_ATTACH_FILTER)
+	{
+		mlibc::infoLogger() << "mlibc: setsockopt(SO_ATTACH_FILTER) is not implemented correctly" << frg::endlog;
+		return 0;
+	}
+	else if (layer == SOL_SOCKET && number == SO_RCVBUFFORCE)
+	{
+		mlibc::infoLogger() << "mlibc: setsockopt(SO_RCVBUFFORCE) is not implemented correctly" << frg::endlog;
+		return 0;
+	}
+	else if (layer == SOL_SOCKET && number == SO_SNDBUF)
+	{
+		mlibc::infoLogger() << "mlibc: setsockopt() call with SOL_SOCKET and SO_SNDBUF is unimplemented" << frg::endlog;
+		return 0;
+	}
+	else if (layer == SOL_SOCKET && number == SO_KEEPALIVE)
+	{
+		mlibc::infoLogger() << "mlibc: setsockopt() call with SOL_SOCKET and SO_KEEPALIVE is unimplemented" << frg::endlog;
+		return 0;
+	}
+	else if (layer == SOL_SOCKET && number == SO_REUSEADDR)
+	{
+		mlibc::infoLogger() << "mlibc: setsockopt() call with SOL_SOCKET and SO_REUSEADDR is unimplemented" << frg::endlog;
+		return 0;
+	}
+	else if (layer == AF_NETLINK && number == SO_ACCEPTCONN)
+	{
+		mlibc::infoLogger() << "mlibc: setsockopt() call with AF_NETLINK and SO_ACCEPTCONN is unimplemented" << frg::endlog;
+		return 0;
+	}
+	else
+	{
+		mlibc::panicLogger() << "mlibc: Unexpected setsockopt() call, layer: " << layer << " number: " << number << frg::endlog;
+		sys_libc_panic();
+	}
+}
+
+// int sys_msg_recv(int sockfd, struct msghdr *hdr, int flags, ssize_t *length)
+// {
+// 	uintptr_t ret = do_syscall(SYS_recvmsg, sockfd, hdr, flags);
+// 	if (auto e = syscall_error(ret); e)
+//		return e;
+// 	*length = ssize_t(ret);
+// 	return 0;
+// }
+
+// int sys_peername(int fd, struct sockaddr *addr_ptr, socklen_t max_addr_length, socklen_t *actual_length)
+// {
+// 	uintptr_t ret = do_syscall(SYS_getpeername, fd, addr_ptr, &max_addr_length);
+// 	if (auto e = syscall_error(ret); e)
+//		return e;
+// 	*actual_length = max_addr_length;
+// 	return 0;
+// }
+
+// int sys_listen(int fd, int backlog)
+// {
+// 	uintptr_t ret = do_syscall(SYS_listen, fd, backlog);
+// 	if (auto e = syscall_error(ret); e)
+//		return e;
+// 	return 0;
+// }
+
+// int sys_inotify_create(int, int *)
+
+// int sys_fork(pid_t *child)
+// {
+// 	uintptr_t ret = do_syscall(SYS_fork);
+// 	if (auto e = syscall_error(ret); e)
+//		return e;
+// 	*child = pid_t(ret);
+// 	return 0;
+// }
+
+// int sys_execve(const char *path, char *const argv[], char *const envp[])
+// {
+// 	uintptr_t ret = do_syscall(SYS_exec, path, argv, envp);
+// 	if (auto e = syscall_error(ret); e)
+//		return e;
+// 	return ret;
+// }
+
+int sys_fcntl(int fd, int request, va_list args, int *result)
+{
+	uintptr_t ret = do_syscall(SYS_fcntl, fd, request, va_arg(args, uint64_t));
+	if (auto e = syscall_error(ret); e)
+		return e;
+	*result = int(ret);
+	return 0;
+}
+
+int sys_dup(int fd, int flags, int *newfd)
+{
+	(void)flags;
+	uintptr_t ret = do_syscall(SYS_dup, fd);
+	if (auto e = syscall_error(ret); e)
+		return e;
+	*newfd = int(ret);
+	return 0;
+}
+
+int sys_dup2(int fd, int flags, int newfd)
+{
+	uintptr_t ret = do_syscall(SYS_dup3, fd, newfd, flags);
+	if (auto e = syscall_error(ret); e)
+		return e;
+	return 0;
+}
+
+int sys_sigprocmask(int, const sigset_t *__restrict, sigset_t *__restrict)
+{
+	mlibc::infoLogger() << "mlibc: sys_sigprocmask() is a stub" << frg::endlog;
+	return 0;
+}
+
+int sys_sigaction(int, const struct sigaction *, struct sigaction *)
+{
+	mlibc::infoLogger() << "mlibc: sys_sigaction() is a stub" << frg::endlog;
+	return 0;
+}
+
+// int sys_signalfd_create(sigset_t, int, int *)
+
+// int sys_waitpid(pid_t pid, int *status, int flags, struct rusage *ru, pid_t *ret_pid)
+// {
+// 	if (ru != NULL)
+//  {
+// 		mlibc::infoLogger() << "mlibc: struct rusage in sys_waitpid is unsupported" << frg::endlog;
+// 		return ENOSYS;
+// 	}
+// again:
+// 	uintptr_t ret = do_syscall(SYS_waitpid, pid, status, flags);
+// 	if (auto e = syscall_error(ret); e)
+// 	{
+// 		if (e == EINTR)
+// 			goto again;
+// 		return e;
+// 	}
+// 	*ret_pid = pid_t(ret);
+// 	return 0;
+// }
+
+// int sys_getgroups(size_t, const gid_t *, int *)
+
+// int sys_mount(const char *, const char *, const char *, unsigned long, const void *)
+
+// int sys_umount2(const char *, int)
+
+int sys_gethostname(char *buffer, size_t bufsize)
+{
+	struct utsname utsname;
+	if (int err = sys_uname(&utsname))
+		return err;
+	if (strlen(utsname.nodename) >= bufsize)
+		return ENAMETOOLONG;
+	strncpy(buffer, utsname.nodename, bufsize);
+	return 0;
+}
+
+// int sys_sethostname(const char *, size_t)
+
+// int sys_sleep(time_t *secs, long *nanos)
+// {
+// 	struct timespec time = { .tv_sec = *secs, .tv_nsec = *nanos };
+// 	struct timespec rem = { .tv_sec = 0, .tv_nsec = 0 };
+// 	uintptr_t ret = do_syscall(SYS_sleep, &time, &rem);
+// 	if (auto e = syscall_error(ret); e)
+//		return e;
+// 	*secs = rem.tv_sec;
+// 	*nanos = rem.tv_nsec;
+// 	return 0;
+// }
+
+int sys_getitimer(int, struct itimerval *)
+{
+	mlibc::infoLogger() << "mlibc: sys_getitimer() is unimplemented" << frg::endlog;
+	return ENOSYS;
+}
+
+int sys_setitimer(int, const struct itimerval *, struct itimerval *)
+{
+	mlibc::infoLogger() << "mlibc: sys_setitimer() is unimplemented" << frg::endlog;
+	return ENOSYS;
+}
+
+int sys_umask(mode_t mode, mode_t *old)
+{
+	uintptr_t ret = do_syscall(SYS_umask, mode);
+	*old = mode_t(ret);
+	return 0;
+}
+
+int sys_uname(struct utsname *buf)
+{
+	uintptr_t ret = do_syscall(SYS_uname, buf);
+	if (auto e = syscall_error(ret); e)
+		return e;
+	return 0;
+}
+
+int sys_fsync(int)
+{
+	mlibc::infoLogger() << "sys_fsync is a stub" << frg::endlog;
+	return 0;
+}
+
+
+int sys_getrlimit(int resource, struct rlimit *limit) STUB_ONLY(getrlimit)
+// {
+// 	uintptr_t ret = do_syscall(SYS_getrlimit, resource, limit);
+// 	if (auto e = syscall_error(ret); e)
+// 		return e;
+// 	return 0;
+// }
+
+// int sys_vm_protect(void *, size_t, int)
+
+#endif
+
+} // namespace mlibc
diff --git a/sysdeps/ilobilix/include/abi-bits/access.h b/sysdeps/ilobilix/include/abi-bits/access.h
new file mode 120000
index 00000000..cb839316
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/access.h
@@ -0,0 +1 @@
+../../../../abis/linux/access.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/auxv.h b/sysdeps/ilobilix/include/abi-bits/auxv.h
new file mode 120000
index 00000000..c43f8786
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/auxv.h
@@ -0,0 +1 @@
+../../../../abis/linux/auxv.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/blkcnt_t.h b/sysdeps/ilobilix/include/abi-bits/blkcnt_t.h
new file mode 120000
index 00000000..0b0ec270
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/blkcnt_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/blkcnt_t.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/blksize_t.h b/sysdeps/ilobilix/include/abi-bits/blksize_t.h
new file mode 120000
index 00000000..7dc8d7cf
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/blksize_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/blksize_t.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/clockid_t.h b/sysdeps/ilobilix/include/abi-bits/clockid_t.h
new file mode 120000
index 00000000..6a42da56
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/clockid_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/clockid_t.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/dev_t.h b/sysdeps/ilobilix/include/abi-bits/dev_t.h
new file mode 120000
index 00000000..bca881e9
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/dev_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/dev_t.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/epoll.h b/sysdeps/ilobilix/include/abi-bits/epoll.h
new file mode 120000
index 00000000..eb4b76dc
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/epoll.h
@@ -0,0 +1 @@
+../../../../abis/linux/epoll.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/errno.h b/sysdeps/ilobilix/include/abi-bits/errno.h
new file mode 120000
index 00000000..6e507def
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/errno.h
@@ -0,0 +1 @@
+../../../../abis/linux/errno.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/fcntl.h b/sysdeps/ilobilix/include/abi-bits/fcntl.h
new file mode 120000
index 00000000..463e2c95
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/fcntl.h
@@ -0,0 +1 @@
+../../../../abis/linux/fcntl.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/fsblkcnt_t.h b/sysdeps/ilobilix/include/abi-bits/fsblkcnt_t.h
new file mode 120000
index 00000000..898dfb2f
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/fsblkcnt_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/fsblkcnt_t.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/fsfilcnt_t.h b/sysdeps/ilobilix/include/abi-bits/fsfilcnt_t.h
new file mode 120000
index 00000000..791755c9
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/fsfilcnt_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/fsfilcnt_t.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/gid_t.h b/sysdeps/ilobilix/include/abi-bits/gid_t.h
new file mode 120000
index 00000000..abce6d69
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/gid_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/gid_t.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/in.h b/sysdeps/ilobilix/include/abi-bits/in.h
new file mode 120000
index 00000000..418d1d5c
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/in.h
@@ -0,0 +1 @@
+../../../../abis/linux/in.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/ino_t.h b/sysdeps/ilobilix/include/abi-bits/ino_t.h
new file mode 120000
index 00000000..4c20aca2
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/ino_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/ino_t.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/inotify.h b/sysdeps/ilobilix/include/abi-bits/inotify.h
new file mode 120000
index 00000000..b5cb2823
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/inotify.h
@@ -0,0 +1 @@
+../../../../abis/linux/inotify.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/ioctls.h b/sysdeps/ilobilix/include/abi-bits/ioctls.h
new file mode 120000
index 00000000..595106b6
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/ioctls.h
@@ -0,0 +1 @@
+../../../../abis/linux/ioctls.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/limits.h b/sysdeps/ilobilix/include/abi-bits/limits.h
new file mode 120000
index 00000000..6c88db2e
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/limits.h
@@ -0,0 +1 @@
+../../../../abis/linux/limits.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/mode_t.h b/sysdeps/ilobilix/include/abi-bits/mode_t.h
new file mode 120000
index 00000000..5d78fdfc
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/mode_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/mode_t.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/mqueue.h b/sysdeps/ilobilix/include/abi-bits/mqueue.h
new file mode 120000
index 00000000..fa87b078
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/mqueue.h
@@ -0,0 +1 @@
+../../../../abis/linux/mqueue.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/nlink_t.h b/sysdeps/ilobilix/include/abi-bits/nlink_t.h
new file mode 120000
index 00000000..bb3b625c
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/nlink_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/nlink_t.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/packet.h b/sysdeps/ilobilix/include/abi-bits/packet.h
new file mode 120000
index 00000000..998ef1ab
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/packet.h
@@ -0,0 +1 @@
+../../../../abis/linux/packet.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/pid_t.h b/sysdeps/ilobilix/include/abi-bits/pid_t.h
new file mode 120000
index 00000000..baa90f6a
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/pid_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/pid_t.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/poll.h b/sysdeps/ilobilix/include/abi-bits/poll.h
new file mode 120000
index 00000000..8ea6a0a3
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/poll.h
@@ -0,0 +1 @@
+../../../../abis/linux/poll.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/ptrace.h b/sysdeps/ilobilix/include/abi-bits/ptrace.h
new file mode 120000
index 00000000..b2517b2c
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/ptrace.h
@@ -0,0 +1 @@
+../../../../abis/linux/ptrace.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/reboot.h b/sysdeps/ilobilix/include/abi-bits/reboot.h
new file mode 120000
index 00000000..77013a41
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/reboot.h
@@ -0,0 +1 @@
+../../../../abis/linux/reboot.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/resource.h b/sysdeps/ilobilix/include/abi-bits/resource.h
new file mode 120000
index 00000000..88d74025
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/resource.h
@@ -0,0 +1 @@
+../../../../abis/linux/resource.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/seek-whence.h b/sysdeps/ilobilix/include/abi-bits/seek-whence.h
new file mode 120000
index 00000000..df7bccf0
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/seek-whence.h
@@ -0,0 +1 @@
+../../../../abis/linux/seek-whence.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/shm.h b/sysdeps/ilobilix/include/abi-bits/shm.h
new file mode 120000
index 00000000..067d8c4f
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/shm.h
@@ -0,0 +1 @@
+../../../../abis/linux/shm.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/signal.h b/sysdeps/ilobilix/include/abi-bits/signal.h
new file mode 120000
index 00000000..4dcb0b7c
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/signal.h
@@ -0,0 +1 @@
+../../../../abis/linux/signal.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/socket.h b/sysdeps/ilobilix/include/abi-bits/socket.h
new file mode 120000
index 00000000..f1dc016e
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/socket.h
@@ -0,0 +1 @@
+../../../../abis/linux/socket.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/socklen_t.h b/sysdeps/ilobilix/include/abi-bits/socklen_t.h
new file mode 120000
index 00000000..41f3b11f
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/socklen_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/socklen_t.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/stat.h b/sysdeps/ilobilix/include/abi-bits/stat.h
new file mode 120000
index 00000000..1f63b41f
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/stat.h
@@ -0,0 +1 @@
+../../../../abis/linux/stat.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/statfs.h b/sysdeps/ilobilix/include/abi-bits/statfs.h
new file mode 120000
index 00000000..e3d202f5
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/statfs.h
@@ -0,0 +1 @@
+../../../../abis/linux/statfs.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/statvfs.h b/sysdeps/ilobilix/include/abi-bits/statvfs.h
new file mode 120000
index 00000000..1fc80c2a
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/statvfs.h
@@ -0,0 +1 @@
+../../../../abis/linux/statvfs.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/suseconds_t.h b/sysdeps/ilobilix/include/abi-bits/suseconds_t.h
new file mode 120000
index 00000000..9ed65977
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/suseconds_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/suseconds_t.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/termios.h b/sysdeps/ilobilix/include/abi-bits/termios.h
new file mode 120000
index 00000000..ee8f0b09
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/termios.h
@@ -0,0 +1 @@
+../../../../abis/linux/termios.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/time.h b/sysdeps/ilobilix/include/abi-bits/time.h
new file mode 120000
index 00000000..2a026257
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/time.h
@@ -0,0 +1 @@
+../../../../abis/linux/time.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/uid_t.h b/sysdeps/ilobilix/include/abi-bits/uid_t.h
new file mode 120000
index 00000000..b3067778
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/uid_t.h
@@ -0,0 +1 @@
+../../../../abis/linux/uid_t.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/utsname.h b/sysdeps/ilobilix/include/abi-bits/utsname.h
new file mode 120000
index 00000000..b2857547
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/utsname.h
@@ -0,0 +1 @@
+../../../../abis/linux/utsname.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/vm-flags.h b/sysdeps/ilobilix/include/abi-bits/vm-flags.h
new file mode 120000
index 00000000..bbe258cf
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/vm-flags.h
@@ -0,0 +1 @@
+../../../../abis/linux/vm-flags.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/wait.h b/sysdeps/ilobilix/include/abi-bits/wait.h
new file mode 120000
index 00000000..feb2840c
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/wait.h
@@ -0,0 +1 @@
+../../../../abis/linux/wait.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/abi-bits/xattr.h b/sysdeps/ilobilix/include/abi-bits/xattr.h
new file mode 120000
index 00000000..66412d70
--- /dev/null
+++ b/sysdeps/ilobilix/include/abi-bits/xattr.h
@@ -0,0 +1 @@
+../../../../abis/linux/xattr.h
\ No newline at end of file
diff --git a/sysdeps/ilobilix/include/ilobilix/syscall.h b/sysdeps/ilobilix/include/ilobilix/syscall.h
new file mode 100644
index 00000000..9b306514
--- /dev/null
+++ b/sysdeps/ilobilix/include/ilobilix/syscall.h
@@ -0,0 +1,144 @@
+#ifndef _ILOBILIX__SYSCALL_H
+#define _ILOBILIX__SYSCALL_H
+
+#include <stdint.h>
+
+#if defined(__x86_64__)
+
+#define SYS_read 0
+#define SYS_write 1
+#define SYS_open 2
+#define SYS_close 3
+#define SYS_stat 4
+#define SYS_fstat 5
+#define SYS_lstat 6
+#define SYS_lseek 8
+#define SYS_mmap 9
+#define SYS_munmap 11
+#define SYS_ioctl 16
+#define SYS_dup 32
+#define SYS_dup2 33
+#define SYS_getpid 39
+#define SYS_exit 60
+#define SYS_uname 63
+#define SYS_fcntl 72
+#define SYS_getcwd 79
+#define SYS_link 86
+#define SYS_unlink 87
+#define SYS_readlink 89
+#define SYS_fchmod 91
+#define SYS_umask 95
+#define SYS_getppid 110
+#define SYS_arch_prctl 158
+#define SYS_openat 257
+#define SYS_fstatat 262
+#define SYS_unlinkat 263
+#define SYS_linkat 265
+#define SYS_readlinkat 267
+#define SYS_fchmodat 268
+#define SYS_dup3 292
+
+#ifdef __SYSCALL_USE_INT__
+#   define __SYSCALL__ "int $0x80"
+#else
+#   define __SYSCALL__ "syscall"
+#endif
+
+static inline uintptr_t __syscall0(uintptr_t n)
+{
+    uintptr_t ret;
+    asm volatile (__SYSCALL__ : "=a"(ret) : "a"(n) : "rcx", "r11", "memory");
+    return ret;
+}
+
+static inline uintptr_t __syscall1(uintptr_t n, uintptr_t a1)
+{
+    uintptr_t ret;
+    asm volatile (__SYSCALL__ : "=a"(ret) : "a"(n), "D"(a1) : "rcx", "r11", "memory");
+    return ret;
+}
+
+static inline uintptr_t __syscall2(uintptr_t n, uintptr_t a1, uintptr_t a2)
+{
+    uintptr_t ret;
+    asm volatile (__SYSCALL__ : "=a"(ret) : "a"(n), "D"(a1), "S"(a2) : "rcx", "r11", "memory");
+    return ret;
+}
+
+static inline uintptr_t __syscall3(uintptr_t n, uintptr_t a1, uintptr_t a2, uintptr_t a3)
+{
+    uintptr_t ret;
+    asm volatile (__SYSCALL__ : "=a"(ret) : "a"(n), "D"(a1), "S"(a2), "d"(a3) : "rcx", "r11", "memory");
+    return ret;
+}
+
+static inline uintptr_t __syscall4(uintptr_t n, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4)
+{
+    uintptr_t ret;
+    register uintptr_t r10 asm("r10") = a4;
+    asm volatile (__SYSCALL__ : "=a"(ret) : "a"(n), "D"(a1), "S"(a2), "d"(a3), "r"(r10): "rcx", "r11", "memory");
+    return ret;
+}
+
+static inline uintptr_t __syscall5(uintptr_t n, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4, uintptr_t a5)
+{
+    uintptr_t ret;
+    register uintptr_t r10 asm("r10") = a4;
+    register uintptr_t r8 asm("r8") = a5;
+    asm volatile (__SYSCALL__ : "=a"(ret) : "a"(n), "D"(a1), "S"(a2), "d"(a3), "r"(r10), "r"(r8) : "rcx", "r11", "memory");
+    return ret;
+}
+
+static inline uintptr_t __syscall6(uintptr_t n, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4, uintptr_t a5, uintptr_t a6)
+{
+    uintptr_t ret;
+    register uintptr_t r10 asm("r10") = a4;
+    register uintptr_t r8 asm("r8") = a5;
+    register uintptr_t r9 asm("r9") = a6;
+    asm volatile (__SYSCALL__ : "=a"(ret) : "a"(n), "D"(a1), "S"(a2), "d"(a3), "r"(r10), "r"(r8), "r"(r9) : "rcx", "r11", "memory");
+    return ret;
+}
+
+#undef __SYSCALL__
+
+#elif defined(__aarch64__)
+
+#define SYS_getcwd 17
+#define SYS_dup 23
+#define SYS_dup3 24
+#define SYS_fcntl 25
+#define SYS_ioctl 29
+#define SYS_unlinkat 35
+#define SYS_linkat 37
+#define SYS_fchmod 52
+#define SYS_fchmodat 53
+#define SYS_openat 56
+#define SYS_close 57
+#define SYS_lseek 62
+#define SYS_read 63
+#define SYS_write 64
+#define SYS_readlinkat 78
+#define SYS_fstatat 79
+#define SYS_exit 93
+#define SYS_uname 160
+#define SYS_umask 166
+#define SYS_getpid 172
+#define SYS_getppid 173
+#define SYS_munmap 216
+#define SYS_mmap 222
+
+static inline uintptr_t __syscall0(uintptr_t n) { return -1; }
+static inline uintptr_t __syscall1(uintptr_t n, uintptr_t a1) { return -1; }
+static inline uintptr_t __syscall2(uintptr_t n, uintptr_t a1, uintptr_t a2) { return -1; }
+static inline uintptr_t __syscall3(uintptr_t n, uintptr_t a1, uintptr_t a2, uintptr_t a3) { return -1; }
+static inline uintptr_t __syscall4(uintptr_t n, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4) { return -1; }
+static inline uintptr_t __syscall5(uintptr_t n, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4, uintptr_t a5) { return -1; }
+static inline uintptr_t __syscall6(uintptr_t n, uintptr_t a1, uintptr_t a2, uintptr_t a3, uintptr_t a4, uintptr_t a5, uintptr_t a6) { return -1; }
+
+#endif
+
+#define GET_MACRO(_1,_2,_3,_4,_5,_6,_7,NAME,...) NAME
+#define __syscall(...) GET_MACRO(__VA_ARGS__, __syscall6, __syscall5, __syscall4, __syscall3, __syscall2, __syscall1, __syscall0)(__VA_ARGS__)
+#define syscall __syscall
+
+#endif
diff --git a/sysdeps/ilobilix/meson.build b/sysdeps/ilobilix/meson.build
new file mode 100644
index 00000000..c3d3efaa
--- /dev/null
+++ b/sysdeps/ilobilix/meson.build
@@ -0,0 +1,92 @@
+
+rtdl_dso_sources += files(
+	'generic/sysdeps.cpp'
+)
+
+libc_sources += files(
+	'generic/entry.cpp',
+	'generic/sysdeps.cpp'
+)
+
+if not no_headers
+	install_headers(
+		'include/abi-bits/auxv.h',
+		'include/abi-bits/seek-whence.h',
+		'include/abi-bits/vm-flags.h',
+		'include/abi-bits/errno.h',
+		'include/abi-bits/fcntl.h',
+		'include/abi-bits/in.h',
+		'include/abi-bits/reboot.h',
+		'include/abi-bits/resource.h',
+		'include/abi-bits/stat.h',
+		'include/abi-bits/signal.h',
+		'include/abi-bits/socket.h',
+		'include/abi-bits/termios.h',
+		'include/abi-bits/time.h',
+		'include/abi-bits/blkcnt_t.h',
+		'include/abi-bits/blksize_t.h',
+		'include/abi-bits/dev_t.h',
+		'include/abi-bits/gid_t.h',
+		'include/abi-bits/ino_t.h',
+		'include/abi-bits/mode_t.h',
+		'include/abi-bits/nlink_t.h',
+		'include/abi-bits/pid_t.h',
+		'include/abi-bits/uid_t.h',
+		'include/abi-bits/access.h',
+		'include/abi-bits/wait.h',
+		'include/abi-bits/limits.h',
+		'include/abi-bits/utsname.h',
+		'include/abi-bits/ptrace.h',
+		'include/abi-bits/poll.h',
+		'include/abi-bits/epoll.h',
+		'include/abi-bits/packet.h',
+		'include/abi-bits/inotify.h',
+		'include/abi-bits/clockid_t.h',
+		'include/abi-bits/shm.h',
+		'include/abi-bits/mqueue.h',
+		'include/abi-bits/suseconds_t.h',
+		'include/abi-bits/fsfilcnt_t.h',
+		'include/abi-bits/fsblkcnt_t.h',
+		'include/abi-bits/socklen_t.h',
+		'include/abi-bits/statfs.h',
+		'include/abi-bits/statvfs.h',
+		'include/abi-bits/ioctls.h',
+		'include/abi-bits/xattr.h',
+		subdir: 'abi-bits'
+	)
+
+	install_headers(
+		'include/ilobilix/syscall.h',
+		subdir: 'ilobilix',
+	)
+endif
+
+if not headers_only
+	crt = custom_target('crt0',
+		build_by_default: true,
+		command: c_compiler.cmd_array() + ['-c', '-o', '@OUTPUT@', '@INPUT@'],
+		input: host_machine.cpu_family() / 'crt-src/crt0.S',
+		output: 'crt0.o',
+		install: true,
+		install_dir: get_option('libdir')
+	)
+
+	custom_target('crti',
+		build_by_default: true,
+		command: c_compiler.cmd_array() + ['-c', '-o', '@OUTPUT@', '@INPUT@'],
+		input: host_machine.cpu_family() / 'crt-src/crti.S',
+		output: 'crti.o',
+		install: true,
+		install_dir: get_option('libdir')
+	)
+
+	custom_target('crtn',
+		build_by_default: true,
+		command: c_compiler.cmd_array() + ['-c', '-o', '@OUTPUT@', '@INPUT@'],
+		input: host_machine.cpu_family() / 'crt-src/crtn.S',
+		output: 'crtn.o',
+		install: true,
+		install_dir: get_option('libdir')
+	)
+endif
+
diff --git a/sysdeps/ilobilix/x86_64/crt-src/crt0.S b/sysdeps/ilobilix/x86_64/crt-src/crt0.S
new file mode 100644
index 00000000..4a5cf860
--- /dev/null
+++ b/sysdeps/ilobilix/x86_64/crt-src/crt0.S
@@ -0,0 +1,8 @@
+.section .text
+.global _start
+_start:
+    mov %rsp, %rdi
+    mov $main, %rsi
+    call __mlibc_entry
+.section .note.GNU-stack,"",%progbits
+
diff --git a/sysdeps/ilobilix/x86_64/crt-src/crti.S b/sysdeps/ilobilix/x86_64/crt-src/crti.S
new file mode 100644
index 00000000..911b078d
--- /dev/null
+++ b/sysdeps/ilobilix/x86_64/crt-src/crti.S
@@ -0,0 +1,11 @@
+.section .init
+.global _init
+_init:
+	push %rax
+
+.section .fini
+.global _fini
+_fini:
+	push %rax
+.section .note.GNU-stack,"",%progbits
+
diff --git a/sysdeps/ilobilix/x86_64/crt-src/crtn.S b/sysdeps/ilobilix/x86_64/crt-src/crtn.S
new file mode 100644
index 00000000..0187e50f
--- /dev/null
+++ b/sysdeps/ilobilix/x86_64/crt-src/crtn.S
@@ -0,0 +1,9 @@
+.section .init
+	pop %rax
+	ret
+
+.section .fini
+	pop %rax
+	ret
+.section .note.GNU-stack,"",%progbits
+
-- 
2.37.2

