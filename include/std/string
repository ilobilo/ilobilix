// Copyright (C) 2022-2023  ilobilo

#pragma once

#define NOSTD_STRING_FLOAT 0
#include <nostd/string.hpp>

namespace std
{
    using namespace nostd;
} // namespace std
using namespace nostd::literals::string_literals;

// string has been moved to an external repository
/*
#pragma GCC system_header

#define USE_NEW_STRING 1
#if USE_NEW_STRING

#include <string_view>
#include <iterator>
#include <concepts>
#include <cassert>
#include <cstdlib>
#include <memory>

#include <lib/hash.hpp>

constexpr inline size_t hasher(const void *ptr, uint64_t len)
{
    return _hash(ptr, len);
}

namespace std
{
    namespace detail
    {
        template<typename Allocator, typename = void>
        struct is_allocator : false_type { };

        template<typename Allocator>
        struct is_allocator<Allocator, void_t<typename Allocator::value_type, decltype(declval<Allocator&>().allocate(size_t { }))>> : true_type { };

        template<typename Allocator>
        constexpr inline bool is_allocator_v = is_allocator<Allocator>::value;

        struct uninitialized_size_tag { };

        template<typename>
        constexpr bool dependent_false = false;

        // template<typename Iterator>
        // concept is_input_iterator = convertible_to<typename iterator_traits<Iterator>::iterator_category, input_iterator_tag>;
    } // namespace detail

    // basic_string
    // based on implementations from llvm project and libstdc++
    // TODO: checks for max_size length errors
    template<typename Char, typename Traits = char_traits<Char>, typename Allocator = allocator<Char>>
    class basic_string
    {
        using alloc_traits = allocator_traits<Allocator>;
        using sview_type = basic_string_view<Char, Traits>;

        public:
        using traits_type = Traits;
        using value_type = typename traits_type::char_type;
        using allocator_type = Allocator;
        using size_type = typename alloc_traits::size_type;
        using difference_type = typename alloc_traits::difference_type;
        using reference = value_type &;
        using const_reference = const value_type &;
        using pointer = typename alloc_traits::pointer;
        using const_pointer = typename alloc_traits::const_pointer;
        using iterator = value_type *;
        using const_iterator = const value_type *;
        using reverse_iterator = reverse_iterator<iterator>;
        using const_reverse_iterator = std::reverse_iterator<const_iterator>;

        constexpr static size_type npos = -1;

        private:
        constexpr static auto _terminator = value_type();

        Allocator _allocator;

        struct long_data
        {
            struct [[gnu::packed]]
            {
                size_type is_long : 1;
                size_type cap : sizeof(size_t) * __CHAR_BIT__ - 1;
            };
            size_type size;
            pointer data;
        };

        enum { min_cap = (sizeof(long_data) - 1) / sizeof(value_type) > 2 ? (sizeof(long_data) - 1) / sizeof(value_type) : 2 };
        struct short_data
        {
            struct [[gnu::packed]]
            {
                unsigned char is_long : 1;
                unsigned char size : 7;
            };
            char padding[sizeof(value_type) - 1];
            value_type data[min_cap];
        };
        static_assert(sizeof(short_data) == (sizeof(value_type) * (min_cap + 1)), "short_data has an unexpected size.");

        union storage_t
        {
            long_data _long;
            short_data _short { { false, 0 }, { }, { } };
        } storage;

        constexpr static bool fits_in_sso(size_type size)
        {
            return size < min_cap;
        }

        constexpr void long_init()
        {
            this->storage._long.is_long = true;
            this->storage._long.data = nullptr;
            this->storage._long.size = 0;
            this->storage._long.cap = 0;
        }

        constexpr void short_init()
        {
            if (auto &buffer = this->storage._long.data; this->is_long() && buffer != nullptr)
            {
                this->_allocator.deallocate(buffer, this->storage._long.cap + 1);
                buffer = nullptr;
            }

            this->storage._short.is_long = false;
            this->storage._short.size = 0;
        }

        constexpr void default_init(size_type size)
        {
            if (fits_in_sso(size))
                this->short_init();
            else
                this->long_init();
        }

        constexpr bool is_long() const noexcept
        {
            return this->storage._short.is_long == true;
        }

        constexpr pointer get_data() noexcept
        {
            return this->is_long() ? this->storage._long.data : this->storage._short.data;
        }

        constexpr const_pointer get_data() const noexcept
        {
            return this->is_long() ? this->storage._long.data : this->storage._short.data;
        }

        constexpr size_type get_size() const noexcept
        {
            return this->is_long() ? this->storage._long.size : this->storage._short.size;
        }

        constexpr void set_size(size_type size) noexcept
        {
            if (this->is_long())
                this->storage._long.size = size;
            else
                this->storage._short.size = size & 0x7F;
        }

        constexpr size_type get_cap() const noexcept
        {
            if (this->is_long())
                return this->storage._long.cap;
            else
                return min_cap;
        }

        constexpr sview_type get_view() const noexcept
        {
            return sview_type(this->get_data(), this->get_size());
        }

        constexpr void reallocate(size_t new_cap, bool copy_old)
        {
            if (new_cap == this->storage._long.cap)
                return;

            auto old_len = this->storage._long.size;
            auto old_cap = this->storage._long.cap;
            auto &old_buffer = this->storage._long.data;

            auto new_len = min(new_cap, old_len);
            auto new_buffer = this->_allocator.allocate(new_cap + 1);

            if (old_buffer != nullptr)
            {
                if (old_len != 0 && copy_old == true)
                    Traits::copy(new_buffer, old_buffer, new_len);
                this->_allocator.deallocate(old_buffer, old_cap + 1);
            }

            this->storage._long.size = new_len;
            this->storage._long.data = new_buffer;
            this->storage._long.cap = new_cap;
        }

        constexpr void grow_to(size_type new_cap)
        {
            if (this->is_long() == true)
            {
                this->reallocate(new_cap, true);
                return;
            }

            auto buffer = this->_allocator.allocate(new_cap + 1);
            auto len = this->storage._short.size;

            Traits::copy(buffer, this->storage._short.data, len);
            Traits::assign(buffer[len], _terminator);

            this->long_init();
            this->storage._long.data = buffer;
            this->storage._long.size = len;
            this->storage._long.cap = new_cap;
        }

        constexpr void null_terminate() noexcept
        {
            auto buffer = this->get_data();
            if (buffer == nullptr)
                return;
            Traits::assign(buffer[this->get_size()], _terminator);
        }

        constexpr bool addr_in_range(const_pointer ptr) const
        {
            if (std::is_constant_evaluated())
                return false;
            return this->get_data() <= ptr && ptr <= this->get_data() + this->get_size();
        }

        constexpr void internal_replace_impl(auto func, size_type pos, size_type oldcount, size_type count)
        {
            auto cap = this->get_cap();
            auto sz = this->get_size();

            auto rsz = sz - oldcount + count;

            if (cap < rsz)
                this->grow_to(rsz);

            if (oldcount != count)
                Traits::move(this->get_data() + pos + count, this->get_data() + pos + oldcount, sz - pos - oldcount);

            func();

            this->set_size(rsz);
            this->null_terminate();
        }

        constexpr void internal_replace(size_type pos, const_pointer str, size_type oldcount, size_type count)
        {
            if (this->addr_in_range(str))
            {
                basic_string rstr(str, count);
                this->internal_replace_impl([=, &rstr]() { Traits::copy(this->get_data() + pos, rstr.data(), count); }, pos, oldcount, count);
            }
            else this->internal_replace_impl([=]() { Traits::copy(this->get_data() + pos, str, count); }, pos, oldcount, count);
        }

        constexpr void internal_replace(size_type pos, value_type ch, size_type oldcount, size_type count)
        {
            this->internal_replace_impl([=]() { Traits::assign(this->get_data() + pos, count, ch); }, pos, oldcount, count);
        }

        constexpr void internal_insert_impl(auto func, size_type pos, size_type size)
        {
            if (size != 0)
            {
                auto cap = this->get_cap();
                auto sz = this->get_size();
                auto rsz = sz + size;

                if (cap < rsz)
                    this->grow_to(rsz);

                Traits::move(this->get_data() + pos + size, this->get_data() + pos, sz - pos);
                func();

                this->set_size(rsz);
                this->null_terminate();
            }
        }

        constexpr void internal_insert(size_type pos, const_pointer str, size_type count)
        {
            if (this->addr_in_range(str))
            {
                basic_string rstr(str, count);
                this->internal_insert_impl([=, &rstr]() { Traits::copy(this->get_data() + pos, rstr.data(), count); }, pos, count);
            }
            else this->internal_insert_impl([=]() { Traits::copy(this->get_data() + pos, str, count); }, pos, count);
        }

        constexpr void internal_insert(size_type pos, value_type ch, size_type count)
        {
            this->internal_insert_impl([=]() { Traits::assign(this->get_data() + pos, count, ch); }, pos, count);
        }

        constexpr void internal_append_impl(auto func, size_type size)
        {
            if (size != 0)
            {
                auto cap = this->get_cap();
                auto sz = this->get_size();
                auto rsz = sz + size;

                if (cap < rsz)
                    this->grow_to(rsz);

                func(sz);
                this->set_size(rsz);
                this->null_terminate();
            }
        }

        constexpr void internal_append(const_pointer str, size_type count)
        {
            if (this->addr_in_range(str))
            {
                basic_string rstr(str, count);
                this->internal_append_impl([=, &rstr](size_type pos) { Traits::copy(this->get_data() + pos, rstr.data(), count); }, count);
            }
            else this->internal_append_impl([=](size_type pos) { Traits::copy(this->get_data() + pos, str, count); }, count);
        }

        constexpr void internal_append(value_type ch, size_type count)
        {
            this->internal_append_impl([=](size_type pos) { Traits::assign(this->get_data() + pos, count, ch); }, count);
        }

        constexpr void internal_assign_impl(auto func, size_type size, bool copy_old)
        {
            if (fits_in_sso(size))
            {
                if (this->is_long() == true)
                    this->short_init();

                this->storage._short.size = size;
                func(this->storage._short.data);
                this->null_terminate();
            }
            else
            {
                if (this->is_long() == false)
                    this->long_init();
                if (this->storage._long.cap < size)
                    this->reallocate(size, copy_old);

                func(this->storage._long.data);
                this->storage._long.size = size;
                this->null_terminate();
            }
        }

        constexpr void internal_assign(const_pointer str, size_type size, bool copy_old = false)
        {
            if (this->addr_in_range(str))
            {
                basic_string rstr(str, size);
                this->internal_assign_impl([=, &rstr](auto data) { Traits::copy(data, rstr.data(), size); }, size, copy_old);
            }
            else this->internal_assign_impl([&](auto data) { Traits::copy(data, str, size); }, size, copy_old);
        }

        constexpr void internal_assign(value_type ch, size_type count, bool copy_old = false)
        {
            this->internal_assign_impl([=](auto data) { Traits::assign(data, count, ch); }, count, copy_old);
        }

        public:
        explicit basic_string(detail::uninitialized_size_tag, size_type size, const allocator_type &a) : _allocator(a)
        {
            if (fits_in_sso(size))
                this->short_init();
            else
            {
                this->long_init();
                this->reallocate(size, false);
            }
            this->set_size(size);
        }

        constexpr basic_string() noexcept(noexcept(allocator_type())) : basic_string(allocator_type()) { }
        explicit constexpr basic_string(const allocator_type &a) noexcept : _allocator(a)
        {
            this->short_init();
        }

        constexpr basic_string(size_type count, value_type ch, const allocator_type &a = allocator_type()) requires (
            detail::is_allocator_v<Allocator>
        ) : _allocator(a)
        {
            this->internal_assign(ch, count);
        }

        constexpr basic_string(const basic_string &str, size_type pos, size_type count, const allocator_type &a = allocator_type()) : _allocator(a)
        {
            assert(pos <= str.get_size());

            auto len = min(count, str.get_size() - pos);

            // this->default_init(len);
            this->internal_assign(str.data(), len);
        }
        constexpr basic_string(const basic_string &str, size_type pos, const allocator_type &a = allocator_type()) : basic_string(str, pos, npos, a) { }

        constexpr basic_string(const value_type *str, size_type count, const allocator_type &a = allocator_type()) : _allocator(a)
        {
            // this->default_init(count);
            this->internal_assign(str, count);
        }
        constexpr basic_string(const value_type *str, const allocator_type &a = allocator_type()) requires (detail::is_allocator_v<Allocator>) : basic_string(str, Traits::length(str), a) { }

        // template<detail::is_input_iterator InputIterator>
        template<std::input_iterator InputIterator>
        constexpr basic_string(InputIterator first, InputIterator last, const allocator_type &a = allocator_type()) : _allocator(a)
        {
            auto len = distance(first, last);
            // this->default_init(len);
            this->internal_assign(const_pointer(first), len);
        }

        constexpr basic_string(const basic_string &str, const allocator_type &a)
        {
            auto len = str.length();
            // this->default_init(len);
            this->internal_assign(str.data(), len);
        }
        constexpr basic_string(const basic_string &str) : basic_string(str, allocator_type()) { }

        constexpr basic_string(basic_string &&str, const allocator_type &a) : _allocator(a), storage(move(str.storage))
        {
            if (str.is_long() && a != str._allocator)
            {
                auto len = str.storage._long.size;
                // this->default_init(len);
                this->internal_assign(str.storage._long.data, len);
            }
            else
            {
                this->storage = str.storage;
                str.short_init();
            }
        }
        constexpr basic_string(basic_string &&str) noexcept : basic_string(str, move(str._allocator)) { }

        constexpr basic_string(initializer_list<value_type> ilist, const allocator_type &a = allocator_type()) : _allocator(a)
        {
            auto len = ilist.size();
            // this->default_init(len);
            this->internal_assign(const_pointer(ilist.begin()), len);
        }

        template<typename Type> requires (
            is_convertible_v<const Type&, sview_type>
        )
        constexpr basic_string(const Type &t, size_type pos, size_type count, const allocator_type &a = allocator_type()) : _allocator(a)
        {
            auto sv = sview_type(t).substr(pos, count);
            auto len = sv.length();

            // this->default_init(len);
            this->internal_assign(sv.data(), len);
        }

        template<typename Type> requires (
            is_convertible_v<const Type&, sview_type> &&
            !is_convertible_v<const Type&, const Char*>
        )
        explicit constexpr basic_string(const Type &t, const allocator_type &a = allocator_type()) : _allocator(a)
        {
            sview_type sv(t);
            auto len = sv.length();

            // this->default_init(len);
            this->internal_assign(sv.data(), len);
        }

        // constexpr basic_string(basic_string &&str, size_type pos, size_type count, const allocator_type &a = allocator_type());
        // constexpr basic_string(basic_string &&str, size_type pos, const allocator_type &a = allocator_type());

        basic_string(nullptr_t) = delete;

        constexpr ~basic_string()
        {
            if (this->is_long())
                if (auto &buffer = this->storage._long.data; buffer != nullptr)
                    this->_allocator.deallocate(buffer, this->storage._long.cap + 1);
        }

        constexpr basic_string &operator=(const basic_string &str)
        {
            return this->assign(str);
        }

        constexpr basic_string &operator=(basic_string &&str) noexcept (
            alloc_traits::propagate_on_container_move_assignment::value ||
            alloc_traits::is_always_equal::value
        )
        {
            return this->assign(str);
        }

        constexpr basic_string &operator=(const value_type *str)
        {
            return this->assign(str, Traits::length(str));
        }

        constexpr basic_string &operator=(value_type ch)
        {
            return this->assign(addressof(ch), 1);
        }

        constexpr basic_string &operator=(initializer_list<value_type> ilist)
        {
            return this->assign(ilist.begin(), ilist.size());
        }

        template<typename Type> requires (
            is_convertible_v<const Type&, sview_type> &&
            !is_convertible_v<const Type&, const Char*>
        )
        constexpr basic_string &operator=(const Type &t)
        {
            sview_type sv(t);
            return this->assign(sv);
        }

        constexpr basic_string &operator=(nullptr_t) = delete;

        constexpr basic_string &assign(size_type count, value_type ch)
        {
            this->internal_assign(ch, count);
            return *this;
        }

        constexpr basic_string &assign(const basic_string &str)
        {
            this->internal_assign(str.data(), str.size());
            return *this;
        }

        constexpr basic_string &assign(const basic_string &str, size_type pos, size_type count = npos)
        {
            assert(pos <= str.size());
            this->internal_assign(str.data(), min(count, str.size() - pos));
            return *this;
        }

        constexpr basic_string &assign(basic_string &&str) noexcept (
            alloc_traits::propagate_on_container_move_assignment::value ||
            alloc_traits::is_always_equal::value
        )
        {
            if (this->_allocator == str._allocator)
                this->swap(str);
            else
                this->internal_assign(str.data(), str.size());

            return *this;
        }

        constexpr basic_string &assign(const value_type *str, size_type count)
        {
            this->internal_assign(str, count);
            return *this;
        }

        constexpr basic_string &assign(const value_type *str)
        {
            return this->assign(str, Traits::length(str));
        }

        template<typename InputIterator>
        constexpr basic_string &assign(InputIterator first, InputIterator last)
        {
            auto len = distance(first, last);

            this->internal_assign(const_pointer(first), len);
            return *this;
        }

        constexpr basic_string &assign(initializer_list<value_type> ilist)
        {
            this->internal_assign(const_pointer(ilist.begin()), ilist.size());
            return *this;
        }

        template<typename Type> requires (
            is_convertible_v<const Type&, sview_type> &&
            !is_convertible_v<const Type&, const Char*>
        )
        constexpr basic_string &assign(const Type &t)
        {
            sview_type sv(t);
            return this->assign(sv.data(), sv.length());
        }

        template<typename Type> requires (
            is_convertible_v<const Type&, sview_type> &&
            !is_convertible_v<const Type&, const Char*>
        )
        constexpr basic_string &assign(const Type &t, size_type pos, size_type count = npos)
        {
            auto sv = sview_type(t).substr(pos, count);
            return this->assign(sv.data(), sv.length());
        }

        constexpr allocator_type get_allocator() const noexcept
        {
            return this->_allocator;
        }

        constexpr reference operator[](size_type pos)
        {
            return this->get_data()[pos];
        }

        constexpr const_reference operator[](size_type pos) const
        {
            return this->get_data()[pos];
        }

        constexpr reference at(size_type pos)
        {
            assert(pos < this->get_size());
            return this->get_data()[pos];
        }

        constexpr const_reference at(size_type pos) const
        {
            assert(pos < this->get_size());
            return this->get_data()[pos];
        }

        constexpr reference front()
        {
            return this->get_data()[0];
        }

        constexpr const_reference front() const
        {
            return this->get_data()[0];
        }

        constexpr reference back()
        {
            return this->get_data()[this->get_size() - 1];
        }

        constexpr const_reference back() const
        {
            return this->get_data()[this->get_size() - 1];
        }

        constexpr const value_type *data() const noexcept
        {
            return this->get_data();
        }

        constexpr value_type *data() noexcept
        {
            return this->get_data();
        }

        constexpr const value_type *c_str() const noexcept
        {
            return this->get_data();
        }

        constexpr operator sview_type() const noexcept
        {
            return this->get_view();
        }

        constexpr iterator begin() noexcept
        {
            return this->get_data();
        }

        constexpr const_iterator begin() const noexcept
        {
            return this->get_data();
        }

        constexpr const_iterator cbegin() const noexcept
        {
            return this->get_data();
        }

        constexpr iterator end() noexcept
        {
            return this->get_data() + this->get_size();
        }

        constexpr const_iterator end() const noexcept
        {
            return this->get_data() + this->get_size();
        }

        constexpr const_iterator cend() const noexcept
        {
            return this->get_data() + this->get_size();
        }

        constexpr reverse_iterator rbegin() noexcept
        {
            return reverse_iterator(this->end());
        }

        constexpr const_reverse_iterator rbegin() const noexcept
        {
            return const_reverse_iterator(this->end());
        }

        constexpr const_reverse_iterator crbegin() const noexcept
        {
            return const_reverse_iterator(this->cend());
        }

        constexpr reverse_iterator rend() noexcept
        {
            return reverse_iterator(this->begin());
        }

        constexpr const_reverse_iterator rend() const noexcept
        {
            return const_reverse_iterator(this->begin());
        }

        constexpr const_reverse_iterator crend() const noexcept
        {
            return const_reverse_iterator(this->cbegin());
        }

        constexpr bool empty() const noexcept
        {
            return this->get_size() == 0;
        }

        constexpr size_type size() const noexcept
        {
            return this->get_size();
        }

        constexpr size_type length() const noexcept
        {
            return this->get_size();
        }

        constexpr size_type max_size() const noexcept
        {
            // size_type m = alloc_traits::max_size(this->_allocator);

            // if (m <= numeric_limits<size_type>::max() / 2)
            //     return m - alignment;
            // else
            //     return (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__) ? m - alignment : (m / 2) - alignment;
            return (alloc_traits::max_size(allocator_type()) - 1) / 2;
        }

        constexpr void reserve(size_type cap)
        {
            if (cap <= this->get_cap())
                return;

            auto new_cap = max(cap, this->get_size());
            if (new_cap == this->get_cap())
                return;

            this->grow_to(new_cap);
        }

        [[deprecated]] void reserve()
        {
            this->shrink_to_fit();
        }

        constexpr size_type capacity() const noexcept
        {
            return this->get_cap();
        }

        constexpr void shrink_to_fit()
        {
            if (this->is_long() == false)
                return;

            this->reallocate(this->get_size(), true);
        }

        constexpr void clear() noexcept
        {
            this->set_size(0);
        }

        constexpr basic_string &insert(size_type pos, size_type count, value_type ch)
        {
            assert(pos <= this->length());
            this->insert(next(this->cbegin(), pos), count, ch);
            return *this;
        }

        constexpr basic_string &insert(size_type pos, const value_type *str)
        {
            assert(pos <= this->length());
            this->internal_insert(pos, str, Traits::length(str));
            return *this;
        }

        constexpr basic_string &insert(size_type pos, const value_type *str, size_type count)
        {
            assert(pos <= this->length());
            this->internal_insert(pos, str, count);
            return *this;
        }

        constexpr basic_string &insert(size_type pos, const basic_string &str)
        {
            assert(pos <= this->length());
            this->internal_insert(pos, const_pointer(str.get_data()), str.length());
            return *this;
        }

        constexpr basic_string &insert(size_type pos, const basic_string &str, size_type pos_str, size_type count = npos)
        {
            assert(pos <= this->length() && pos_str <= str.length());
            count = min(count, str.length() - pos_str);
            return this->insert(pos, str.data() + pos_str, count);
        }

        constexpr iterator insert(const_iterator pos, value_type ch)
        {
            return this->insert(pos, 1, ch);
        }

        constexpr iterator insert(const_iterator pos, size_type count, value_type ch)
        {
            auto spos = distance(this->cbegin(), pos);
            this->internal_insert(spos, ch, count);
            return next(this->begin(), spos);
        }

        template<typename InputIterator>
        constexpr iterator insert(const_iterator pos, InputIterator first, InputIterator last)
        {
            auto spos = distance(this->cbegin(), pos);
            auto len = distance(first, last);
            this->internal_insert(spos, const_pointer(first), len);
            return next(this->begin(), spos);
        }

        constexpr iterator insert(const_iterator pos, initializer_list<value_type> ilist)
        {
            auto spos = distance(this->cbegin(), pos);
            this->internal_insert(spos, const_pointer(ilist.begin()), ilist.size());
            return next(this->begin(), spos);
        }

        template<typename Type> requires (
            is_convertible_v<const Type&, sview_type> &&
            !is_convertible_v<const Type&, const Char*>
        )
        constexpr basic_string &insert(size_type pos, const Type &t)
        {
            assert(pos <= this->length());
            sview_type sv(t);
            this->internal_insert(pos, const_pointer(sv.data()), sv.length());
            return *this;
        }

        template<typename Type> requires (
            is_convertible_v<const Type&, sview_type> &&
            !is_convertible_v<const Type&, const Char*>
        )
        constexpr basic_string &insert(size_type pos, const Type &t, size_type pos_str, size_type count = npos)
        {
            assert(pos <= this->length());
            auto sv = sview_type(t).substr(pos_str, count);
            this->internal_insert(pos, const_pointer(sv.data()), sv.length());
            return *this;
        }

        constexpr basic_string &erase(size_type pos = 0, size_type count = npos)
        {
            auto sz = this->get_size();
            auto buffer = this->get_data();

            assert(pos <= sz);
            count = min(count, sz - pos);

            auto left = sz - (pos + count);
            if (left != 0)
                Traits::move(buffer + pos, buffer + pos + count, left);

            auto new_size = pos + left;
            this->set_size(new_size);
            this->null_terminate();

            return *this;
        }

        constexpr iterator erase(const_iterator position)
        {
            auto pos = distance(this->cbegin(), position);
            this->erase(pos, 1);
            return this->begin() + pos;
        }

        constexpr iterator erase(const_iterator first, const_iterator last)
        {
            auto pos = distance(this->cbegin(), first);
            auto len = distance(first, last);
            this->erase(pos, len);
            return this->begin() + pos;
        }

        constexpr void push_back(value_type ch)
        {
            this->append(1, ch);
        }

        constexpr void pop_back()
        {
            this->erase(this->end() - 1);
        }

        constexpr basic_string &append(size_type count, value_type ch)
        {
            this->internal_append(ch, count);
            return *this;
        }

        constexpr basic_string &append(const basic_string &str)
        {
            this->internal_append(str.get_data(), str.get_size());
            return *this;
        }

        constexpr basic_string &append(const basic_string &str, size_type pos, size_type count = npos)
        {
            auto sz = str.get_size();
            assert(pos <= sz);
            this->internal_append(str.get_data() + pos, min(count, sz - pos));
            return *this;
        }

        constexpr basic_string &append(const value_type *str, size_type count)
        {
            this->internal_append(str, count);
            return *this;
        }

        constexpr basic_string &append(const value_type *str)
        {
            return this->append(str, Traits::length(str));
        }

        template<typename InputIterator>
        constexpr basic_string &append(InputIterator first, InputIterator last)
        {
            auto len = distance(first, last);
            this->internal_append(const_pointer(first), len);
            return *this;
        }

        constexpr basic_string &append(initializer_list<value_type> ilist)
        {
            this->internal_append(const_pointer(ilist.begin()), ilist.size());
            return *this;
        }

        template<typename Type> requires (
            is_convertible_v<const Type&, sview_type> &&
            !is_convertible_v<const Type&, const Char*>
        )
        constexpr basic_string &append(const Type &t)
        {
            sview_type sv(t);
            this->internal_append(sv.data(), sv.size());
            return *this;
        }

        template<typename Type> requires (
            is_convertible_v<const Type&, sview_type> &&
            !is_convertible_v<const Type&, const Char*>
        )
        constexpr basic_string &append(const Type &t, size_type pos, size_type count = npos)
        {
            sview_type sv(t);
            assert(pos < sv.size());
            this->internal_append(sv.data(), min(count, sv.size() - pos));
            return *this;
        }

        constexpr basic_string &operator+=(const basic_string &str)
        {
            return this->append(str);
        }

        constexpr basic_string &operator+=(value_type ch)
        {
            this->push_back(ch);
            return *this;
        }

        constexpr basic_string &operator+=(const value_type *str)
        {
            return this->append(str);
        }

        constexpr basic_string &operator+=(initializer_list<value_type> ilist)
        {
            return this->append(ilist);
        }

        template<typename Type> requires (
            is_convertible_v<const Type&, sview_type> &&
            !is_convertible_v<const Type&, const Char*>
        )
        constexpr basic_string &operator+=(const Type &t)
        {
            return this->append(sview_type(t));
        }

        constexpr int compare(const basic_string &str) const noexcept
        {
            return this->get_view().compare(str.get_view());
        }

        constexpr int compare(size_type pos1, size_type count1, const basic_string &str) const
        {
            return this->get_view().compare(pos1, count1, str.get_view());
        }

        constexpr int compare(size_type pos1, size_type count1, const basic_string &str, size_type pos2, size_type count2 = npos) const
        {
            return this->get_view().compare(pos1, count1, str.get_view(), pos2, count2);
        }

        constexpr int compare(const value_type *str) const
        {
            return this->get_view().compare(str);
        }

        constexpr int compare(size_type pos1, size_type count1, const value_type *str) const
        {
            return this->get_view().compare(pos1, count1, str);
        }

        constexpr int compare(size_type pos1, size_type count1, const value_type *str, size_type count2) const
        {
            return this->get_view().compare(pos1, count1, str, count2);
        }

        template<typename Type> requires (
            is_convertible_v<const Type&, sview_type> &&
            !is_convertible_v<const Type&, const Char*>
        )
        constexpr int compare(const Type &t) const noexcept(noexcept(is_nothrow_convertible_v<const Type&, sview_type>))
        {
            return this->get_view().compare(sview_type(t));
        }

        template<typename Type> requires (
            is_convertible_v<const Type&, sview_type> &&
            !is_convertible_v<const Type&, const Char*>
        )
        constexpr int compare(size_type pos1, size_type count1, const Type &t) const
        {
            return this->get_view().compare(pos1, count1, sview_type(t));
        }

        template<typename Type> requires (
            is_convertible_v<const Type&, sview_type> &&
            !is_convertible_v<const Type&, const Char*>
        )
        constexpr int compare(size_type pos1, size_type count1, const Type &t, size_type pos2, size_type count2 = npos) const
        {
            return this->get_view().compare(pos1, count1, sview_type(t), pos2, count2);
        }

        constexpr bool starts_with(sview_type sv) const noexcept
        {
            return this->get_view().starts_with(sv);
        }

        constexpr bool starts_with(Char ch) const noexcept
        {
            return this->get_view().starts_with(ch);
        }

        constexpr bool starts_with(const Char *str) const
        {
            return this->get_view().starts_with(str);
        }

        constexpr bool ends_with(sview_type sv) const noexcept
        {
            return this->get_view().ends_with(sv);
        }

        constexpr bool ends_with(Char ch) const noexcept
        {
            return this->get_view().ends_with(ch);
        }

        constexpr bool ends_with(const Char *str) const
        {
            return this->get_view().ends_with(str);
        }

        constexpr bool contains(sview_type sv) const noexcept
        {
            return this->get_view().contains(sv);
        }

        constexpr bool contains(Char ch) const noexcept
        {
            return this->get_view().contains(ch);
        }

        constexpr bool contains(const Char *str) const
        {
            return this->get_view().contains(str);
        }

        constexpr basic_string &replace(size_type pos, size_type count, const basic_string &str)
        {
            return this->replace(pos, count, str, 0, str.length());
        }

        constexpr basic_string &replace(const_iterator first, const_iterator last, const basic_string &str)
        {
            auto pos = distance(this->cbegin(), first);
            auto count = distance(first, last);
            return this->replace(pos, count, str, 0, str.length());
        }

        constexpr basic_string &replace(size_type pos, size_type count, const basic_string &str, size_type pos2, size_type count2 = npos)
        {
            assert(pos <= this->length() && pos2 <= str.length());
            count2 = min(count2, str.length() - pos2);
            return this->replace(pos, count, str.data() + pos2, count2);
        }

        template<typename InputIterator>
        constexpr basic_string &replace(const_iterator first, const_iterator last, InputIterator first2, InputIterator last2)
        {
            return this->replace(first, last, const_pointer(first2), distance(first2, last2));
        }

        constexpr basic_string &replace(size_type pos, size_type count, const value_type *str, size_type count2)
        {
            assert(pos <= this->length());
            count = min(count, this->length() - pos);
            this->internal_replace(pos, const_pointer(str), count, count2);
            return *this;
        }

        constexpr basic_string &replace(const_iterator first, const_iterator last, const value_type *str, size_type count2)
        {
            size_type pos = distance(this->cbegin(), first);
            size_type count = distance(first, last);

            return this->replace(pos, count, str, count2);
        }

        constexpr basic_string &replace(size_type pos, size_type count, const value_type *str)
        {
            return this->replace(pos, count, str, Traits::length(str));
        }

        constexpr basic_string &replace(const_iterator first, const_iterator last, const value_type *str)
        {
            return this->replace(first, last, str, Traits::length(str));
        }

        constexpr basic_string &replace(size_type pos, size_type count, size_type count2, value_type ch)
        {
            assert(pos <= this->length());
            count = min(count, this->length() - pos);
            this->internal_replace(pos, ch, count, count2);
            return *this;
        }

        constexpr basic_string &replace(const_iterator first, const_iterator last, size_type count2, value_type ch)
        {
            auto pos = distance(this->cbegin(), first);
            auto count = distance(first, last);

            assert(pos <= this->length());
            this->internal_replace(pos, ch, count, count2);
            return *this;
        }

        constexpr basic_string &replace(const_iterator first, const_iterator last, initializer_list<value_type> ilist)
        {
            return this->replace(first, last, const_pointer(ilist.begin()), ilist.size());
        }

        template<typename Type> requires (
            is_convertible_v<const Type&, sview_type> &&
            !is_convertible_v<const Type&, const Char*>
        )
        constexpr basic_string &replace(size_type pos, size_type count, const Type &t)
        {
            sview_type sv(t);
            return this->replace(pos, count, sv.data(), sv.length());
        }

        template<typename Type> requires (
            is_convertible_v<const Type&, sview_type> &&
            !is_convertible_v<const Type&, const Char*>
        )
        constexpr basic_string &replace(const_iterator first, const_iterator last, const Type &t)
        {
            sview_type sv(t);
            return this->replace(first, last, sv.data(), sv.length());
        }

        template<typename Type> requires (
            is_convertible_v<const Type&, sview_type> &&
            !is_convertible_v<const Type&, const Char*>
        )
        constexpr basic_string &replace(size_type pos, size_type count, const Type &t, size_type pos2, size_type count2 = npos)
        {
            auto sv = sview_type(t).substr(pos2, count2);
            return this->replace(pos, count, sv.data(), sv.length());
        }

        constexpr basic_string substr(size_type pos = 0, size_type count = npos) const
        {
            return basic_string(*this, pos, count);
        }

        constexpr size_type copy(value_type *str, size_type count, size_type pos = 0) const
        {
            return this->get_view().copy(str, count, pos);
        }

        constexpr void resize(size_type count, value_type ch)
        {
            auto cap = this->get_cap();
            auto sz = this->get_size();
            auto rsz = count + sz;

            if (sz < rsz)
            {
                if (cap < rsz)
                    this->grow_to(rsz);
                Traits::assign(this->get_data() + sz, count, ch);
            }
            this->set_size(rsz);
            this->null_terminate();
        }

        constexpr void resize(size_type count)
        {
            this->resize(count, _terminator);
        }

        template<typename Operation>
        constexpr void resize_and_overwrite(size_type count, Operation op)
        {
            static_assert(detail::dependent_false<Char>, "std::basic_string::resize_and_overwrite(count, op) not implemented!");
        }

        constexpr void swap(basic_string &str) noexcept(alloc_traits::propagate_on_container_swap::value || alloc_traits::is_always_equal::value)
        {
            using std::swap;
            swap(this->storage, str.storage);
            swap(this->_allocator, str._allocator);
        }

        constexpr size_type find(const basic_string &str, size_type pos = 0) const noexcept
        {
            return this->get_view().find(sview_type(str), pos);
        }

        constexpr size_type find(const value_type *str, size_type pos, size_type count) const noexcept
        {
            return this->get_view().find(str, pos, count);
        }

        constexpr size_type find(const value_type *str, size_type pos = 0) const noexcept
        {
            return this->get_view().find(str, pos);
        }

        constexpr size_type find(value_type ch, size_type pos = 0) const noexcept
        {
            return this->get_view().find(ch, pos);
        }

        template<typename Type> requires (
            is_convertible_v<const Type&, sview_type> &&
            !is_convertible_v<const Type&, const Char*>
        )
        constexpr size_type find(const Type &t, size_type pos = 0) const noexcept(is_nothrow_convertible_v<const Type&, sview_type>)
        {
            return this->get_view().find(sview_type(t), pos);
        }

        constexpr size_type rfind(const basic_string &str, size_type pos = npos) const noexcept
        {
            return this->get_view().rfind(sview_type(str), pos);
        }

        constexpr size_type rfind(const value_type *str, size_type pos, size_type count) const noexcept
        {
            return this->get_view().rfind(str, pos, count);
        }

        constexpr size_type rfind(const value_type *str, size_type pos = npos) const noexcept
        {
            return this->get_view().rfind(str, pos);
        }

        constexpr size_type rfind(value_type ch, size_type pos = npos) const noexcept
        {
            return this->get_view().rfind(ch, pos);
        }

        template<typename Type> requires (
            is_convertible_v<const Type&, sview_type> &&
            !is_convertible_v<const Type&, const Char*>
        )
        constexpr size_type rfind(const Type &t, size_type pos = npos) const noexcept(is_nothrow_convertible_v<const Type&, sview_type>)
        {
            return this->get_view().rfind(sview_type(t), pos);
        }

        constexpr size_type find_first_of(const basic_string &str, size_type pos = 0) const noexcept
        {
            return this->get_view().find_first_of(sview_type(str), pos);
        }

        constexpr size_type find_first_of(const value_type *str, size_type pos, size_type count) const noexcept
        {
            return this->get_view().find_first_of(str, pos, count);
        }

        constexpr size_type find_first_of(const value_type *str, size_type pos = 0) const noexcept
        {
            return this->get_view().find_first_of(str, pos);
        }

        constexpr size_type find_first_of(value_type ch, size_type pos = 0) const noexcept
        {
            return this->get_view().find_first_of(ch, pos);
        }

        template<typename Type> requires (
            is_convertible_v<const Type&, sview_type> &&
            !is_convertible_v<const Type&, const Char*>
        )
        constexpr size_type find_first_of(const Type &t, size_type pos = 0) const noexcept(is_nothrow_convertible_v<const Type&, sview_type>)
        {
            return this->get_view().find_first_of(sview_type(t), pos);
        }

        constexpr size_type find_first_not_of(const basic_string &str, size_type pos = 0) const noexcept
        {
            return this->get_view().find_last_not_of(sview_type(str), pos);
        }

        constexpr size_type find_first_not_of(const value_type *str, size_type pos, size_type count) const noexcept
        {
            return this->get_view().find_last_not_of(str, pos, count);
        }

        constexpr size_type find_first_not_of(const value_type *str, size_type pos = 0) const noexcept
        {
            return this->get_view().find_last_not_of(str, pos);
        }

        constexpr size_type find_first_not_of(value_type ch, size_type pos = 0) const noexcept
        {
            return this->get_view().find_first_not_of(ch, pos);
        }

        template<typename Type> requires (
            is_convertible_v<const Type&, sview_type> &&
            !is_convertible_v<const Type&, const Char*>
        )
        constexpr size_type find_first_not_of(const Type &t, size_type pos = 0) const noexcept(is_nothrow_convertible_v<const Type&, sview_type>)
        {
            return this->get_view().find_first_not_of(sview_type(t), pos);
        }

        constexpr size_type find_last_of(const basic_string &str, size_type pos = npos) const noexcept
        {
            return this->get_view().find_last_of(sview_type(str), pos);
        }

        constexpr size_type find_last_of(const value_type *str, size_type pos, size_type count) const noexcept
        {
            return this->get_view().find_last_of(str, pos, count);
        }

        constexpr size_type find_last_of(const value_type *str, size_type pos = npos) const noexcept
        {
            return this->get_view().find_last_of(str, pos);
        }

        constexpr size_type find_last_of(value_type ch, size_type pos = npos) const noexcept
        {
            return this->get_view().find_last_of(ch, pos);
        }

        template<typename Type> requires (
            is_convertible_v<const Type&, sview_type> &&
            !is_convertible_v<const Type&, const Char*>
        )
        constexpr size_type find_last_of(const Type &t, size_type pos = npos) const noexcept(is_nothrow_convertible_v<const Type&, sview_type>)
        {
            return this->get_view().find_last_of(sview_type(t), pos);
        }

        constexpr size_type find_last_not_of(const basic_string &str, size_type pos = npos) const noexcept
        {
            return this->get_view().find_last_not_of(sview_type(str), pos);
        }

        constexpr size_type find_last_not_of(const value_type *str, size_type pos, size_type count) const noexcept
        {
            return this->get_view().find_last_not_of(str, pos, count);
        }

        constexpr size_type find_last_not_of(const value_type *str, size_type pos = npos) const noexcept
        {
            return this->get_view().find_last_not_of(str, pos);
        }

        constexpr size_type find_last_not_of(value_type ch, size_type pos = npos) const noexcept
        {
            return this->get_view().find_last_not_of(ch, pos);
        }

        template<typename Type> requires (
            is_convertible_v<const Type&, sview_type> &&
            !is_convertible_v<const Type&, const Char*>
        )
        constexpr size_type find_last_not_of(const Type &t, size_type pos = npos) const noexcept(is_nothrow_convertible_v<const Type&, sview_type>)
        {
            return this->get_view().find_last_not_of(sview_type(t), pos);
        }

        friend constexpr basic_string operator+(const basic_string &lhs, const basic_string &rhs)
        {
            auto lhs_sz = lhs.size();
            auto rhs_sz = rhs.size();
            basic_string ret(detail::uninitialized_size_tag(), lhs_sz + rhs_sz, basic_string::alloc_traits::select_on_container_copy_construction(lhs.get_allocator()));
            auto buffer = ret.get_data();
            Traits::copy(buffer, lhs.data(), lhs_sz);
            Traits::copy(buffer + lhs_sz, rhs.data(), rhs_sz);
            ret.null_terminate();
            return ret;
        }

        friend constexpr basic_string operator+(basic_string &&lhs, const basic_string &rhs)
        {
            return move(lhs.append(rhs));
        }

        friend constexpr basic_string operator+(const basic_string &lhs, basic_string &&rhs)
        {
            return move(rhs.insert(0, lhs));
        }

        friend constexpr basic_string operator+(basic_string &&lhs, basic_string &&rhs)
        {
            return move(lhs.append(rhs));
        }

        friend constexpr basic_string operator+(const Char *lhs, const basic_string &rhs)
        {
            auto lhs_sz = Traits::length(lhs);
            auto rhs_sz = rhs.size();
            basic_string ret(detail::uninitialized_size_tag(), lhs_sz + rhs_sz, basic_string::alloc_traits::select_on_container_copy_construction(rhs.get_allocator()));
            auto buffer = ret.get_data();
            Traits::copy(buffer, lhs, lhs_sz);
            Traits::copy(buffer + lhs_sz, rhs.data(), rhs_sz);
            ret.null_terminate();
            return ret;
        }

        friend constexpr basic_string operator+(const Char *lhs, basic_string &&rhs)
        {
            return move(rhs.insert(0, lhs));
        }

        friend constexpr basic_string operator+(Char lhs, const basic_string &rhs)
        {
            auto rhs_sz = rhs.size();
            basic_string ret(detail::uninitialized_size_tag(), rhs_sz + 1, basic_string::alloc_traits::select_on_container_copy_construction(rhs.get_allocator()));
            auto buffer = ret.get_data();
            Traits::assign(buffer, 1, lhs);
            Traits::copy(buffer + 1, rhs.data(), rhs_sz);
            ret.null_terminate();
            return ret;
        }

        friend constexpr basic_string operator+(Char lhs, basic_string &&rhs)
        {
            rhs.insert(rhs.begin(), lhs);
            return move(rhs);
        }

        friend constexpr basic_string operator+(const basic_string &lhs, const Char *rhs)
        {
            auto lhs_sz = lhs.size();
            auto rhs_sz = Traits::length(rhs);
            basic_string ret(detail::uninitialized_size_tag(), lhs_sz + rhs_sz, basic_string::alloc_traits::select_on_container_copy_construction(lhs.get_allocator()));
            auto buffer = ret.get_data();
            Traits::copy(buffer, lhs.data(), lhs_sz);
            Traits::copy(buffer + lhs_sz, rhs, rhs_sz);
            ret.null_terminate();
            return ret;
        }

        friend constexpr basic_string operator+(basic_string &&lhs, const Char *rhs)
        {
            return move(lhs.append(rhs));
        }

        friend constexpr basic_string operator+(const basic_string &lhs, Char rhs)
        {
            auto lhs_sz = lhs.size();
            basic_string ret(detail::uninitialized_size_tag(), lhs_sz + 1, basic_string::alloc_traits::select_on_container_copy_construction(lhs.get_allocator()));
            auto buffer = ret.get_data();
            Traits::copy(buffer, lhs.data(), lhs_sz);
            Traits::assign(buffer + lhs_sz, 1, rhs);
            ret.null_terminate();
            return ret;
        }

        friend constexpr basic_string operator+(basic_string &&lhs, Char rhs)
        {
            lhs.push_back(rhs);
            return move(lhs);
        }
    };

    template<typename Char, typename Traits, typename Allocator>
    constexpr bool operator==(const basic_string<Char, Traits, Allocator> &lhs, const basic_string<Char, Traits, Allocator> &rhs) noexcept
    {
        return lhs.compare(rhs) == 0;
    }

    template<typename Char, typename Traits, typename Allocator>
    constexpr bool operator==(const basic_string<Char, Traits, Allocator> &lhs, const Char *rhs)
    {
        return lhs.compare(rhs) == 0;
    }

    template<typename Char, typename Traits, typename Allocator>
    constexpr strong_ordering operator<=>(const basic_string<Char, Traits, Allocator> &lhs, const basic_string<Char, Traits, Allocator> &rhs) noexcept
    {
        return lhs.compare(rhs) <=> 0;
    }

    template<typename Char, typename Traits, typename Allocator>
    constexpr strong_ordering operator<=>(const basic_string<Char, Traits, Allocator> &lhs, const Char *rhs)
    {
        return lhs.compare(rhs) <=> 0;
    }

    // swap
    template<typename Char, typename Traits, typename Allocator>
    constexpr void swap(basic_string<Char, Traits, Allocator> &lhs, basic_string<Char, Traits, Allocator> &rhs) noexcept(noexcept(lhs.swap(rhs)))
    {
        lhs.swap(rhs);
    }

    // erasure
    template<typename Char, typename Traits, typename Allocator, typename U>
    constexpr typename basic_string<Char, Traits, Allocator>::size_type erase(basic_string<Char, Traits, Allocator> &c, const U &value)
    {
        auto it = remove(c.begin(), c.end(), value);
        auto r = distance(it, c.end());
        c.erase(it, c.end());
        return r;
    }

    template<typename Char, typename Traits, typename Allocator, typename Pred>
    constexpr typename basic_string<Char, Traits, Allocator>::size_type erase_if(basic_string<Char, Traits, Allocator> &c, Pred pred)
    {
        auto it = remove_if(c.begin(), c.end(), pred);
        auto r = distance(it, c.end());
        c.erase(it, c.end());
        return r;
    }

    // deduction guides
    template<typename InputIt, typename Allocator = allocator<typename iterator_traits<InputIt>::value_type>>
    basic_string(InputIt, InputIt, Allocator = Allocator()) -> basic_string<typename iterator_traits<InputIt>::value_type, char_traits<typename iterator_traits<InputIt>::value_type>, Allocator>;

    template<typename Char, typename Traits, typename Allocator = allocator<Char>>
    explicit basic_string(basic_string_view<Char, Traits>, const Allocator & = Allocator()) -> basic_string<Char, Traits, Allocator>;

    template<typename Char, typename Traits, typename Allocator = allocator<Char>>
    basic_string(basic_string_view<Char, Traits>, typename basic_string<Char, Traits, Allocator>::size_type, typename basic_string<Char, Traits, Allocator>::size_type, const Allocator & = Allocator()) -> basic_string<Char, Traits, Allocator>;

    // basic_string typedef-names
    using string = basic_string<char>;
    using u8string = basic_string<char8_t>;
    using u16string = basic_string<char16_t>;
    using u32string = basic_string<char32_t>;
    using wstring = basic_string<wchar_t>;

    // numeric conversions
    constexpr inline int stoi(const string &str, size_t *pos = nullptr, int base = 10)
    {
        auto cstr = str.c_str();
        char *ptr = const_cast<char*>(cstr);

        auto ret = strtol(cstr, &ptr, base);
        if (pos != nullptr)
            *pos = cstr - ptr;

        return ret;
    }

    constexpr inline long stol(const string &str, size_t *pos = nullptr, int base = 10)
    {
        auto cstr = str.c_str();
        char *ptr = const_cast<char*>(cstr);

        auto ret = strtol(cstr, &ptr, base);
        if (pos != nullptr)
            *pos = cstr - ptr;

        return ret;
    }

    constexpr inline long long stoll(const string &str, size_t *pos = nullptr, int base = 10)
    {
        auto cstr = str.c_str();
        char *ptr = const_cast<char*>(cstr);

        auto ret = strtoll(cstr, &ptr, base);
        if (pos != nullptr)
            *pos = cstr - ptr;

        return ret;
    }

    constexpr inline unsigned long stoul(const string &str, size_t *pos = nullptr, int base = 10)
    {
        auto cstr = str.c_str();
        char *ptr = const_cast<char*>(cstr);

        auto ret = strtoul(cstr, &ptr, base);
        if (pos != nullptr)
            *pos = cstr - ptr;

        return ret;
    }

    constexpr inline unsigned long long stoull(const string &str, size_t *pos = nullptr, int base = 10)
    {
        auto cstr = str.c_str();
        char *ptr = const_cast<char*>(cstr);

        auto ret = strtoull(cstr, &ptr, base);
        if (pos != nullptr)
            *pos = cstr - ptr;

        return ret;
    }

    // constexpr inline float stof(const string &str, size_t *pos = nullptr);
    // constexpr inline double stod(const string &str, size_t *pos = nullptr);
    // constexpr inline long double stold(const string &str, size_t *pos = nullptr);

    namespace detail
    {
        template<typename Type>
        constexpr size_t to_chars_len(Type value)
        {
            constexpr Type b1 = 10;
            constexpr Type b2 = 100;
            constexpr Type b3 = 1000;
            constexpr Type b4 = 10000;

            for (size_t i = 1; ; i += 4, value /= b4)
            {
                if (value < b1)
                    return i;
                if (value < b2)
                    return i + 1;
                if (value < b3)
                    return i + 2;
                if (value < b4)
                    return i + 3;
            }
        }

        static constexpr char digits[201] =
                "0001020304050607080910111213141516171819"
                "2021222324252627282930313233343536373839"
                "4041424344454647484950515253545556575859"
                "6061626364656667686970717273747576777879"
                "8081828384858687888990919293949596979899";

        constexpr void to_chars(char *first, size_t len, auto val)
        {
            size_t pos = len - 1;
            while (val >= 100)
            {
                auto const num = (val % 100) * 2;
                val /= 100;
                first[pos] = digits[num + 1];
                first[pos - 1] = digits[num];
                pos -= 2;
            }
            if (val >= 10)
            {
                auto const num = val * 2;
                first[1] = digits[num + 1];
                first[0] = digits[num];
            }
            else first[0] = '0' + val;
        }

        template<signed_integral Type, unsigned_integral UType = make_unsigned_t<Type>>
        [[gnu::always_inline]]
        constexpr inline string to_string(Type value)
        {
            const auto negative = value < 0;
            const UType uvalue = negative ? static_cast<UType>(~value) + static_cast<UType>(1) : value;
            const auto length = to_chars_len(uvalue);
            string str(length + negative, '-');
            to_chars(&str[negative], length, uvalue);
            return str;
        }

        template<unsigned_integral Type>
        [[gnu::always_inline]]
        constexpr inline string to_string(Type value)
        {
            string str(to_chars_len(value), '\0');
            to_chars(&str[0], str.length(), value);
            return str;
        }
    } // namespace detail

    constexpr inline string to_string(int val) { return detail::to_string(val); }
    constexpr inline string to_string(unsigned val) { return detail::to_string(val); }
    constexpr inline string to_string(long val) { return detail::to_string(val); }
    constexpr inline string to_string(unsigned long val) { return detail::to_string(val); }
    constexpr inline string to_string(long long val) { return detail::to_string(val); }
    constexpr inline string to_string(unsigned long long val) { return detail::to_string(val); }

    // constexpr inline string to_string(float val);
    // constexpr inline string to_string(double val);
    // constexpr inline string to_string(long double val);

    // constexpr inline wstring to_wstring(int val);
    // constexpr inline wstring to_wstring(unsigned val);
    // constexpr inline wstring to_wstring(long val);
    // constexpr inline wstring to_wstring(unsigned long val);
    // constexpr inline wstring to_wstring(long long val);
    // constexpr inline wstring to_wstring(unsigned long long val);

    // constexpr inline wstring to_wstring(float val);
    // constexpr inline wstring to_wstring(double val);
    // constexpr inline wstring to_wstring(long double val);

    // hash support
    namespace detail
    {
        template<typename Char, typename Allocator, typename String = basic_string<Char, char_traits<Char>, Allocator>>
        struct string_hash_base
        {
            [[nodiscard]] constexpr size_t operator()(const String &str) const noexcept
            {
                return hasher(str.data(), str.length() * sizeof(Char));
            }
        };
    } // namespace detail

    template<typename Allocator>
    struct hash<basic_string<char, char_traits<char>, Allocator>> : detail::string_hash_base<char, Allocator> { };

    template<typename Allocator>
    struct hash<basic_string<char8_t, char_traits<char8_t>, Allocator>> : detail::string_hash_base<char8_t, Allocator> { };

    template<typename Allocator>
    struct hash<basic_string<char16_t, char_traits<char16_t>, Allocator>> : detail::string_hash_base<char16_t, Allocator> { };

    template<typename Allocator>
    struct hash<basic_string<char32_t, char_traits<char32_t>, Allocator>> : detail::string_hash_base<char32_t, Allocator> { };

    template<typename Allocator>
    struct hash<basic_string<wchar_t, char_traits<wchar_t>, Allocator>> : detail::string_hash_base<wchar_t, Allocator> { };

    inline namespace literals
    {
        inline namespace string_literals
        {
            // suffix for basic_string literals
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wuser-defined-literals"
            constexpr inline string operator""s(const char *str, size_t len) { return string { str, len }; }
            constexpr inline u8string operator""s(const char8_t *str, size_t len) { return u8string { str, len }; }
            constexpr inline u16string operator""s(const char16_t *str, size_t len) { return u16string { str, len }; }
            constexpr inline u32string operator""s(const char32_t *str, size_t len) { return u32string { str, len }; }
            constexpr inline wstring operator""s(const wchar_t *str, size_t len) { return wstring { str, len }; }
#pragma clang diagnostic pop
        } // namespace string_literals
    } // namespace literals
} // namespace std

using namespace std::literals::string_literals;

#else

#include <initializer_list>
#include <type_traits>
#include <string_view>
#include <iterator>
#include <concepts>
#include <compare>
#include <cstdlib>
#include <memory>

namespace std
{
    // TODO: Fix basic_string
    template<typename Char, typename Traits = char_traits<Char>, typename Allocator = allocator<Char>>
    class basic_string
    {
        private:
        Allocator _allocator;
        Char *_buffer = nullptr;
        size_t _length = 0;
        size_t _cap = 0;

        public:
        using traits_type = Traits;
        using value_type = Char;
        using allocator_type = Allocator;
        using size_type = typename Allocator::size_type;
        using difference_type = typename Allocator::difference_type;
        using pointer = Char*;
        using const_pointer = const Char*;
        using reference = Char&;
        using const_reference = const Char&;

        using iterator = Char*;
        using const_iterator = const Char*;
        using reverse_iterator = reverse_iterator<iterator>;
        using const_reverse_iterator = std::reverse_iterator<const_iterator>;

        static constexpr size_type npos = size_type(-1);

        private:
        constexpr void null_terminate()
        {
            if (this->_buffer == nullptr || this->_length == 0)
                return;

            this->_buffer[this->_length] = Char(0);
        }

        constexpr Char *reallocate(size_t new_cap)
        {
            auto new_buffer = this->_allocator.allocate(new_cap + 1);

            if (this->_buffer != nullptr)
            {
                auto new_length = min(new_cap, this->_length);
                Traits::copy(new_buffer, this->_buffer, new_length);
                this->_length = new_length;
                this->_allocator.deallocate(this->_buffer, this->_cap + 1);
            }

            this->_buffer = new_buffer;
            this->_cap = new_cap;

            return new_buffer;
        }

        constexpr size_t it2pos(const_iterator pos)
        {
            if (this->_buffer == nullptr || this->_length == 0)
                return npos;

            pos = max(pos, const_iterator(this->_buffer));
            pos = min(pos, const_iterator(this->_buffer + this->_length));

            return static_cast<size_type>(pos - this->_buffer);
        }

        constexpr size_t range2count(const_iterator first, const_iterator last)
        {
            if (this->_buffer == nullptr || this->_length == 0)
                return npos;

            first = max(first, const_iterator(this->_buffer));
            first = min(first, const_iterator(this->_buffer + this->_length));

            last = max(last, const_iterator(this->_buffer));
            last = min(last, const_iterator(this->_buffer + this->_length));

            return static_cast<size_type>(last - first);
        }

        public:
        constexpr basic_string() noexcept(noexcept(Allocator())) : basic_string(Allocator()) { }
        explicit constexpr basic_string(const Allocator &alloc) noexcept : _allocator(alloc), _buffer(nullptr), _length(0), _cap(0) { }

        constexpr basic_string(size_type count, Char c, const Allocator &alloc = Allocator()) : _allocator(alloc), _length(count), _cap(count)
        {
            this->_buffer = this->_allocator.allocate(this->_length + 1);
            Traits::assign(this->_buffer, count, c);
            this->null_terminate();
        }

        constexpr basic_string(const basic_string &other, size_type pos, size_type count, const Allocator &alloc = Allocator()) : _allocator(alloc)
        {
            if (pos + count > other._length)
                count = other._length - pos;

            this->_length = this->_cap = count;

            this->_buffer = this->_allocator.allocate(this->_length + 1);
            Traits::copy(this->_buffer, other._buffer + pos, this->_length);
            this->null_terminate();
        }
        constexpr basic_string(const basic_string &other, size_type pos, const Allocator &alloc = Allocator()) : basic_string(other, pos, other._length, alloc) { }

        constexpr basic_string(const Char *s, size_type count, const Allocator &alloc = Allocator()) : _allocator(alloc), _length(count), _cap(count)
        {
            this->_buffer = this->_allocator.allocate(this->_length + 1);
            Traits::copy(this->_buffer, s, this->_length);
            this->null_terminate();
        }
        constexpr basic_string(const Char *s, const Allocator &alloc = Allocator()) : basic_string(s, Traits::length(s), alloc) { }

        template<typename InputIt>
        constexpr basic_string(InputIt first, InputIt last, const Allocator &alloc = Allocator()) : _allocator(alloc)
        {
            while (first != last)
                this->push_back(*first++);
        }

        constexpr basic_string(const basic_string &other, const Allocator &alloc) : _allocator(alloc), _length(other._length), _cap(other._length)
        {
            this->_buffer = this->_allocator.allocate(this->_length + 1);
            Traits::copy(this->_buffer, other._buffer, this->_length);
            this->null_terminate();
        }

        constexpr basic_string(const basic_string &other) : _allocator(other._allocator), _length(other._length), _cap(other._length)
        {
            this->_buffer = this->_allocator.allocate(this->_length + 1);
            Traits::copy(this->_buffer, other._buffer, this->_length);
            this->null_terminate();
        }

        constexpr basic_string(basic_string &&other, const Allocator &alloc) : basic_string(move(other._buffer), move(other._length), alloc) { }
        constexpr basic_string(basic_string &&other) noexcept : basic_string(other, move(other._allocator)) { }

        constexpr basic_string(initializer_list<Char> ilist, const Allocator &alloc = Allocator()) : basic_string(ilist.begin(), ilist.size(), alloc) { }

        template<typename Type> requires (convertible_to<const Type&, basic_string_view<Char>> && !convertible_to<const Type&, const Char*>)
        explicit constexpr basic_string(const Type &t, const Allocator &alloc = Allocator()) : basic_string(basic_string_view<Char>(t).data(), basic_string_view<Char>(t).size(), alloc) { }

        template<typename Type> requires (convertible_to<const Type&, basic_string_view<Char>>)
        constexpr basic_string(const Type &t, size_type pos, size_type n, const Allocator &alloc = Allocator()) : basic_string(basic_string_view<Char>(t).substr(pos, n), alloc) { }

        constexpr basic_string(nullptr_t) = delete;

        constexpr ~basic_string()
        {
            if (this->_buffer != nullptr)
                this->_allocator.deallocate(this->_buffer, this->_cap + 1);

            this->_length = this->_cap = 0;
        }

        constexpr basic_string &operator=(const basic_string &str) noexcept(
            alloc_traits::propagate_on_container_move_assignment::value ||
            alloc_traits::is_always_equal::value)
        {
            return this->assign(str);
        }

        constexpr basic_string &operator=(basic_string &&str) noexcept(
            alloc_traits::propagate_on_container_move_assignment::value ||
            alloc_traits::is_always_equal::value) = default;

        constexpr basic_string &operator=(const Char *s)
        {
            return this->assign(s, Traits::length(s));
        }

        constexpr basic_string &operator=(Char c)
        {
            return this->assign(addressof(c), 1);
        }

        constexpr basic_string &operator=(initializer_list<Char> ilist)
        {
            return this->assign(ilist.begin(), ilist.size());
        }

        template<typename Type>
        requires (convertible_to<const Type&, basic_string_view<Char>> && !convertible_to<const Type&, const Char*>)
        constexpr basic_string &operator=(const Type &t)
        {
            return this->assign(basic_string_view<Char>(t));
        }

        constexpr basic_string &operator=(nullptr_t) = delete;

        constexpr basic_string &assign(size_type count, Char ch)
        {
            this->clear();
            this->resize(count, ch);
            this->null_terminate();

            return *this;
        }

        constexpr basic_string &assign(const basic_string &str)
        {
            this->clear();
            this->append(str);

            return *this;
        }

        constexpr basic_string &assign(const basic_string &str, size_type pos, size_type count = npos)
        {
            if (pos > str._length) return *this;
            if (pos + count > str._length || count == npos) count = str._length - pos;

            this->clear();
            this->append(str.data() + pos, count);

            return *this;
        }

        constexpr basic_string &assign(basic_string &&str) noexcept(
            alloc_traits::propagate_on_container_move_assignment::value ||
            alloc_traits::is_always_equal::value)
        {
            return this->swap(str);
        }

        constexpr basic_string &assign(const Char *s, size_type count)
        {
            this->clear();
            this->append(s, count);
            this->null_terminate();

            return *this;
        }

        constexpr basic_string &assign(const Char *s)
        {
            this->clear();
            this->append(s, Traits::length(s));
            this->null_terminate();

            return *this;
        }

        constexpr basic_string &assign(initializer_list<Char> ilist)
        {
            return this->assign(ilist.begin(), ilist.size());
        }

        template<typename Type>
        requires (convertible_to<const Type&, basic_string_view<Char>> && !convertible_to<const Type&, const Char*>)
        constexpr basic_string &assign(const Type &t)
        {
            basic_string_view<Char> sv(t);
            return this->assign(sv.data(), sv.size());
        }

        template<typename Type> requires (convertible_to<const Type&, basic_string_view<Char>> && !convertible_to<const Type&, const Char*>)
        constexpr basic_string &assign(const Type &t, size_type pos, size_type count = npos)
        {
            basic_string_view<Char> sv(t);

            if (pos > sv.size())
                return *this;
            if (pos + count > sv.size() || count == npos)
                count = sv.size() - pos;

            return this->assign(sv.data() + pos, count);
        }

        constexpr allocator_type get_allocator() const noexcept
        {
            return this->_allocator;
        }

        constexpr reference at(size_type index)
        {
            assert(index < this->_length);
            return this->_buffer[index];
        }

        constexpr const_reference at(size_type index) const
        {
            assert(index < this->_length);
            return this->_buffer[index];
        }

        constexpr reference operator[](size_type index)
        {
            return this->_buffer[index];
        }

        constexpr const_reference operator[](size_type index) const
        {
            return this->_buffer[index];
        }

        constexpr reference front()
        {
            return this->operator[](0);
        }

        constexpr const_reference front() const
        {
            return this->operator[](0);
        }

        constexpr reference back()
        {
            return this->operator[](this->_length - 1);
        }

        constexpr const_reference back() const
        {
            return this->operator[](this->_length - 1);
        }

        constexpr pointer data() noexcept
        {
            return this->_buffer;
        }

        constexpr const_pointer data() const noexcept
        {
            return this->_buffer;
        }

        constexpr const_pointer c_str() const noexcept
        {
            return this->_buffer;
        }

        constexpr operator basic_string_view<Char>() const noexcept
        {
            return basic_string_view<Char>(this->_buffer, this->_length);
        }

        constexpr iterator begin() noexcept
        {
            return this->_buffer;
        }

        constexpr const_iterator begin() const noexcept
        {
            return this->_buffer;
        }

        constexpr const_iterator cbegin() const noexcept
        {
            return this->_buffer;
        }

        constexpr iterator end() noexcept
        {
            return this->_buffer + this->_length;
        }

        constexpr const_iterator end() const noexcept
        {
            return this->_buffer + this->_length;
        }

        constexpr const_iterator cend() const noexcept
        {
            return this->_buffer + this->_length;
        }

        constexpr reverse_iterator rbegin() noexcept
        {
            return reverse_iterator(this->end());
        }

        constexpr const_reverse_iterator rbegin() const noexcept
        {
            return const_reverse_iterator(this->end());
        }

        constexpr const_reverse_iterator crbegin() const noexcept
        {
            return const_reverse_iterator(this->end());
        }

        constexpr reverse_iterator rend() noexcept
        {
            return reverse_iterator(this->begin());
        }

        constexpr const_reverse_iterator rend() const noexcept
        {
            return const_reverse_iterator(this->begin());
        }

        constexpr const_reverse_iterator crend() const noexcept
        {
            return const_reverse_iterator(this->begin());
        }

        [[nodiscard]] constexpr bool empty() const noexcept
        {
            return this->_length == 0;
        }

        constexpr size_type size() const noexcept
        {
            return this->_length;
        }

        constexpr size_type length() const noexcept
        {
            return this->_length;
        }

        constexpr size_type max_size() const noexcept
        {
            return size_type(-1) / sizeof(Char);
        }

        constexpr void reserve(size_type new_cap)
        {
            if (new_cap == this->_cap || new_cap < this->_cap)
                return;

            this->_buffer = this->reallocate(new_cap);
            this->_cap = new_cap;
        }

        constexpr size_type capacity() const noexcept
        {
            return this->_cap;
        }

        constexpr void shrink_to_fit()
        {
            if (this->_length == this->_cap)
                return;

            this->_buffer = this->reallocate(this->_length);
            this->_cap = this->_length;
        }

        constexpr void clear() noexcept
        {
            this->erase();
        }

        constexpr basic_string &insert(size_type index, size_type count, Char ch)
        {
            if (count == 0)
                return *this;

            if (index > this->_length)
                index = this->_length;

            size_type new_size = this->_length + count;
            this->resize(new_size);

            Traits::move(this->_buffer + index + count, this->_buffer + index, this->_length  - index);
            Traits::assign(this->_buffer + index, count, ch);

            this->_length += count;
            this->null_terminate();
            return *this;
        }

        constexpr basic_string &insert(size_type index, const Char *s)
        {
            return this->insert(index, s, Traits::length(s));
        }

        constexpr basic_string &insert(size_type index, const Char *s, size_type count)
        {
            if (count == 0)
                return *this;

            if (index > this->_length)
                index = this->_length;

            size_type new_size = this->_length + count;
            this->resize(new_size);

            Traits::move(this->_buffer + index + count, this->_buffer + index, this->_length - index);
            Traits::copy(this->_buffer + index, s, count);

            this->_length += count;
            this->null_terminate();
            return *this;
        }

        constexpr basic_string &insert(size_type index, const basic_string &str)
        {
            return this->insert(index, str.c_str(), str.size());
        }

        constexpr basic_string &insert(size_type index, const basic_string &str, size_type index_str, size_type count = npos)
        {
            basic_string newstr = str.substr(index_str, count);
            return this->insert(index, newstr.c_str(), newstr.size());
        }

        constexpr iterator insert(const_iterator pos, Char c)
        {
            this->insert(this->it2pos(pos), 1, c);
            return const_cast<iterator>(pos);
        }

        constexpr iterator insert(const_iterator pos, size_type count, Char c)
        {
            this->insert(this->it2pos(pos), count, c);
            return const_cast<iterator>(pos);
        }

        constexpr iterator insert(const_iterator pos, initializer_list<Char> ilist)
        {
            this->insert(this->it2pos(pos), ilist.begin(), ilist.size());
            return const_cast<iterator>(pos);
        }

        template<typename Type> requires (convertible_to<const Type&, basic_string_view<Char>> && !convertible_to<const Type&, const Char*>)
        constexpr basic_string &insert(size_type pos, const Type &t)
        {
            basic_string_view<Char> sv(t);
            return this->insert(pos, sv.data(), sv.size());
        }

        template<typename Type> requires (convertible_to<const Type&, basic_string_view<Char>> && !convertible_to<const Type&, const Char*>)
        constexpr basic_string &insert(size_type index, const Type &t, size_type index_str, size_type count = npos)
        {
            basic_string_view<Char> sv(t);

            if (index_str >= sv.size())
                return *this;

            if (index_str + count > sv.size() || count == npos)
                count = sv.size() - index_str;

            return this->insert(index, sv.data() + index_str * sizeof(Char), count);
        }

        constexpr basic_string &erase(size_type index = 0, size_type count = npos)
        {
            if (index >= this->_length)
                return *this;

            count = min(count, this->_length - index);
            if (count == 0)
                return *this;

            Traits::move(this->_buffer + index, this->_buffer + index + count, this->_length - (index + count));

            this->_length -= count;
            this->null_terminate();
            return *this;
        }

        constexpr iterator erase(const_iterator pos)
        {
            this->erase(this->it2pos(pos), 1);
            return this->end();
        }

        constexpr iterator erase(const_iterator first, const_iterator last)
        {
            this->erase(this->it2pos(first), this->range2count(first, last));
            return const_cast<iterator>(first);
        }

        constexpr void push_back(Char ch)
        {
            this->append(1, ch);
        }

        constexpr void pop_back()
        {
            this->erase(this->end() - 1);
        }

        constexpr basic_string &append(size_type count, Char ch)
        {
            return this->insert(this->_length, count, ch);
        }

        constexpr basic_string &append(const basic_string &str)
        {
            return this->insert(this->_length, str);
        }

        constexpr basic_string &append(const basic_string &str, size_type pos, size_type count = npos)
        {
            if (pos > str._length) return *this;
            if (pos + count > str._length || count == npos)
                count = str._length - pos;

            return this->insert(this->_length, str.substr);
        }

        constexpr basic_string &append(const Char *s, size_type count)
        {
            return this->insert(this->_length, s, count);
        }

        constexpr basic_string &append(const Char *s)
        {
            return this->insert(this->_length, s, Traits::length(s));
        }

        constexpr basic_string &append(initializer_list<Char> ilist)
        {
            return this->append(ilist.begin(), ilist.size());
        }

        template<typename Type> requires (convertible_to<const Type&, basic_string_view<Char>> && !convertible_to<const Type&, const Char*>)
        constexpr basic_string &append(const Type &t)
        {
            basic_string_view<Char> sv(t);
            return this->append(sv.data(), sv.size());
        }

        template<typename Type> requires (convertible_to<const Type&, basic_string_view<Char>> && !convertible_to<const Type&, const Char*>)
        constexpr basic_string &append(const Type &t, size_type pos, size_type count = npos)
        {
            basic_string_view<Char> sv(t);

            if (pos >= sv.size())
                return *this;
            if (pos + count > sv.size() || count == npos)
                count = sv.size() - pos;

            return this->append(sv.data(), sv.size());
        }

        constexpr basic_string &operator+=(initializer_list<Char> ilist)
        {
            return this->append(ilist.begin(), ilist.size());
        }

        constexpr basic_string &operator+=(const basic_string &str)
        {
            return this->append(str);
        }

        constexpr basic_string &operator+=(Char c)
        {
            return this->append(1, c);
        }

        constexpr basic_string &operator+=(const Char *s)
        {
            return this->append(s);
        }

        template<typename Type> requires (convertible_to<const Type&, basic_string_view<Char>> && !convertible_to<const Type&, const Char*>)
        constexpr basic_string &operator+=(const Type &t)
        {
            basic_string_view<Char> sv(t);
            return this->append(sv);
        }

        constexpr int compare(const basic_string &str) const noexcept
        {
            if (this->_length != str._length)
                return this->_length < str._length ? -1 : 1;
            return Traits::compare(this->_buffer, str._buffer, this->_length);
        }

        constexpr int compare(size_type pos1, size_type count1, const basic_string &str) const
        {
            if (pos1 + count1 > this->_length)
                count1 = this->_length - pos1;

            if (count1 != str._length)
                return count1 < str._length ? -1 : 1;

            return Traits::compare(this->_buffer + pos1, str._buffer, count1);
        }

        constexpr int compare(size_type pos1, size_type count1, const basic_string &str, size_type pos2, size_type count2 = npos) const
        {
            if (pos1 + count1 > this->_length)
                count1 = this->_length - pos1;

            if (pos2 + count2 > str._length)
                count2 = str._length - pos2;

            if (count1 != count2)
                return count1 < count2 ? -1 : 1;

            return Traits::compare(this->_buffer + pos1, str._buffer + pos2, count1);
        }

        constexpr int compare(const Char *s) const
        {
            size_type sl = Traits::length(s);
            if (this->_length != sl)
                return this->_length < sl ? -1 : 1;

            return Traits::compare(this->_buffer, s, this->_length);
        }

        constexpr int compare(size_type pos1, size_type count1, const Char *s) const
        {
            size_type sl = Traits::length(s);
            if (pos1 + count1 > this->_length)
                count1 = this->_length - pos1;
            if (count1 != sl)
                return count1 < sl ? -1 : 1;

            return Traits::compare(this->_buffer + pos1, s, count1);
        }

        constexpr int compare(size_type pos1, size_type count1, const Char *s, size_type count2) const
        {
            if (pos1 + count1 > this->_length)
                count1 = this->_length - pos1;
            if (count1 != count2)
                return count1 < count2 ? -1 : 1;

            return Traits::compare(this->_buffer + pos1, s, count1);
        }

        template<typename Type> requires (convertible_to<const Type&, basic_string_view<Char>> && !convertible_to<const Type&, const Char*>)
        constexpr int compare(const Type &t) const noexcept (is_nothrow_convertible_v<const Type&, basic_string_view<Char, Traits>>)
        {
            basic_string_view<Char> sv(t);
            if (this->_length != sv.size())
                return this->_length < sv.size() ? -1 : 1;

            return Traits::compare(this->_buffer, sv.data(), this->_length);
        }

        template<typename Type> requires (convertible_to<const Type&, basic_string_view<Char>> && !convertible_to<const Type&, const Char*>)
        constexpr int compare(size_type pos1, size_type count1, const Type &t) const
        {
            basic_string_view<Char> sv(t);
            if (count1 != sv.size())
                return count1 < sv.size() ? -1 : 1;

            return basic_string_view<Char>(*this).substr(pos1, count1).compare(sv);
        }

        template<typename Type> requires (convertible_to<const Type&, basic_string_view<Char>> && !convertible_to<const Type&, const Char*>)
        constexpr int compare(size_type pos1, size_type count1, const Type &t, size_type pos2, size_type count2 = npos) const
        {
            basic_string_view<Char> sv(t);
            sv = sv.substr(pos2, count2);
            if (count1 != count2)
                return count1 < count2 ? -1 : 1;

            return basic_string_view<Char>(*this).substr(pos1, count1).compare(sv);
        }

        constexpr bool starts_with(basic_string_view<Char> sv) const noexcept
        {
            return basic_string_view<Char>(this->_buffer, this->_length).starts_with(sv);
        }

        constexpr bool starts_with(Char c) const noexcept
        {
            return basic_string_view<Char>(this->_buffer, this->_length).starts_with(c);
        }

        constexpr bool starts_with(const Char *s) const
        {
            return basic_string_view<Char>(this->_buffer, this->_length).starts_with(s);
        }

        constexpr bool ends_with(basic_string_view<Char> sv) const noexcept
        {
            return basic_string_view<Char>(this->_buffer, this->_length).ends_with(sv);
        }

        constexpr bool ends_with(Char c) const noexcept
        {
            return basic_string_view<Char>(this->_buffer, this->_length).ends_with(c);
        }

        constexpr bool ends_with(const Char *s) const
        {
            return basic_string_view<Char>(this->_buffer, this->_length).ends_with(s);
        }

        constexpr bool contains(basic_string_view<Char> sv) const noexcept
        {
            return this->find(sv) != npos;
        }

        constexpr bool contains(Char c) const noexcept
        {
            return this->find(c) != npos;
        }

        constexpr bool contains(const Char *s) const
        {
            return this->find(s) != npos;
        }

        constexpr basic_string &replace(size_type pos, size_type count, const basic_string &str)
        {
            if (pos > this->_length)
                return *this;
            if (pos + count > this->_length)
                count = this->_length - pos;

            this->erase(pos, count);
            this->insert(pos, str);

            return *this;
        }

        constexpr basic_string &replace(const_iterator first, const_iterator last, const basic_string &str)
        {
            return this->replace(this->it2pos(first), this->range2count(first, last), str);
        }

        constexpr basic_string &replace(size_type pos, size_type count, const basic_string &str, size_type pos2, size_type count2 = npos)
        {
            if (pos > this->_length)
                return *this;
            if (pos + count > this->_length)
                count = this->_length - pos;

            if (pos2 > str._length)
                return *this;
            if (pos2 + count2 > str._length || count2 == npos)
                count2 = str._length - pos2;

            this->erase(pos, count);
            this->insert(pos, str, pos2, count2);

            return *this;
        }

        constexpr basic_string &replace(size_type pos, size_type count, const Char *str, size_type count2)
        {
            if (pos > this->_length)
                return *this;
            if (pos + count > this->_length)
                count = this->_length - pos;

            this->erase(pos, count);
            this->insert(pos, str, count2);

            return *this;
        }

        constexpr basic_string &replace(const_iterator first, const_iterator last, const Char *str, size_type count2)
        {
            return this->replace(this->it2pos(first), this->range2count(first, last), str, count2);
        }

        constexpr basic_string &replace(size_type pos, size_type count, const Char *str)
        {
            if (pos > this->_length) return *this;
            if (pos + count > this->_length) count = this->_length - pos;

            this->erase(pos, count);
            this->insert(pos, str, Traits::length(str));

            return *this;
        }

        constexpr basic_string &replace(const_iterator first, const_iterator last, const Char *str)
        {
            return this->replace(this->it2pos(first), this->range2count(first, last), str);
        }

        constexpr basic_string &replace(size_type pos, size_type count, size_type count2, Char c)
        {
            if (pos > this->_length) return *this;
            if (pos + count > this->_length) count = this->_length - pos;

            this->erase(pos, count);
            this->insert(pos, count2, c);

            return *this;
        }

        constexpr basic_string &replace(const_iterator first, const_iterator last, size_type count2, Char c)
        {
            return this->replace(this->it2pos(first), this->range2count(first, last), count2, c);
        }

        constexpr basic_string &replace(const_iterator first, const_iterator last, initializer_list<Char> ilist)
        {
            return this->replace(this->it2pos(first), this->range2count(first, last), ilist.begin(), ilist.size());
        }

        template<typename Type> requires (convertible_to<const Type&, basic_string_view<Char>> && !convertible_to<const Type&, const Char*>)
        constexpr basic_string &replace(size_type pos, size_type count, const Type &t)
        {
            basic_string_view<Char> sv(t);

            if (pos > this->_length) return *this;
            if (pos + count > this->_length) count = this->_length - pos;

            this->erase(pos, count);
            this->insert(pos, sv.data(), sv.size());

            return *this;
        }

        template<typename Type> requires (convertible_to<const Type&, basic_string_view<Char>> && !convertible_to<const Type&, const Char*>)
        constexpr basic_string &replace(const_iterator first, const_iterator last, const Type &t)
        {
            return this->replace(this->it2pos(first), this->range2count(first, last), t);
        }

        template<typename Type> requires (convertible_to<const Type&, basic_string_view<Char>> && !convertible_to<const Type&, const Char*>)
        constexpr basic_string &replace(size_type pos, size_type count, const Type &t, size_type pos2, size_type count2 = npos)
        {
            basic_string_view<Char> sv(t);

            if (pos > this->_length) return *this;
            if (pos + count > this->_length) count = this->_length - pos;

            if (pos2 > sv.size()) return *this;
            if (pos2 + count2 > sv.size() || count2 == npos) count2 = sv.size() - pos2;

            this->erase(pos, count);
            this->insert(pos, sv.data(), pos2, count2);

            return *this;
        }

        constexpr basic_string substr(size_type pos = 0, size_type count = npos) const
        {
            if (pos >= this->_length)
                return *this;
            if (pos + count > this->_length || count == npos)
                count = this->_length - pos;

            return basic_string(this->_buffer + pos, count);
        }

        constexpr size_type copy(Char *dest, size_type count, size_type pos = 0) const
        {
            if (pos >= this->_length)
                return 0;

            if (pos + count > this->_length || count == npos)
                count = this->_length - pos;

            memcpy(dest, this->_buffer + pos, count);
            return count;
        }

        constexpr void resize(size_type count)
        {
            size_type oldsize = this->_length;

            this->_buffer = this->reallocate(count);
            if (count > oldsize)
                Traits::assign(this->_buffer + oldsize, count - oldsize, 0);

            this->_buffer[count] = 0;

            if (count < oldsize)
                this->_length = count;
            this->_cap = count;
        }

        constexpr void resize(size_type count, Char ch)
        {
            size_type oldsize = this->_length;

            this->_buffer = this->reallocate(count);
            if (count > oldsize)
                Traits::assign(this->_buffer + oldsize, count - oldsize, ch);

            this->_buffer[count] = 0;
            this->_length = this->_cap = count;
        }

        constexpr void swap(basic_string &other)
        {
            using std::swap;
            swap(this->_buffer, other._buffer);
            swap(this->_length, other._length);
            swap(this->_cap, other._cap);
        }

        constexpr size_type find(const basic_string &str, size_type pos = 0) const noexcept
        {
            return basic_string_view<Char>(this->_buffer, this->_length).find(basic_string_view<Char>(str), pos);
        }

        constexpr size_type find(const Char *s, size_type pos, size_type count) const
        {
            return basic_string_view<Char>(this->_buffer, this->_length).find(s, pos, count);
        }

        constexpr size_type find(const Char *s, size_type pos = 0) const
        {
            return basic_string_view<Char>(this->_buffer, this->_length).find(s, pos);
        }

        constexpr size_type find(Char c, size_type pos = 0) const noexcept
        {
            return basic_string_view<Char>(this->_buffer, this->_length).find(c, pos);
        }

        template<typename Type> requires (convertible_to<const Type&, basic_string_view<Char>> && !convertible_to<const Type&, const Char*>)
        constexpr size_type find(const Type &t, size_type pos = 0) const
        {
            return basic_string_view<Char>(this->_buffer, this->_length).find(basic_string_view<Char>(t), pos);
        }

        constexpr size_type rfind(const basic_string &str, size_type pos = npos) const noexcept
        {
            return basic_string_view<Char>(this->_buffer, this->_length).rfind(basic_string_view<Char>(str), pos);
        }

        constexpr size_type rfind(const Char *s, size_type pos, size_type count) const
        {
            return basic_string_view<Char>(this->_buffer, this->_length).rfind(s, pos, count);
        }

        constexpr size_type rfind(const Char *s, size_type pos = npos) const
        {
            return basic_string_view<Char>(this->_buffer, this->_length).rfind(s, pos);
        }

        constexpr size_type rfind(Char c, size_type pos = npos) const noexcept
        {
            return basic_string_view<Char>(this->_buffer, this->_length).rfind(c, pos);
        }

        template<typename Type> requires (convertible_to<const Type&, basic_string_view<Char>> && !convertible_to<const Type&, const Char*>)
        constexpr size_type rfind(const Type &t, size_type pos = npos) const
        {
            return basic_string_view<Char>(this->_buffer, this->_length).rfind(basic_string_view<Char>(t), pos);
        }

        constexpr size_type find_first_of(const basic_string &str, size_type pos = 0) const noexcept
        {
            return basic_string_view<Char>(this->_buffer, this->_length).find_first_of(basic_string_view<Char>(str), pos);
        }

        constexpr size_type find_first_of(const Char *s, size_type pos, size_type count) const
        {
            return basic_string_view<Char>(this->_buffer, this->_length).find_first_of(s, pos, count);
        }

        constexpr size_type find_first_of(const Char *s, size_type pos = 0) const
        {
            return basic_string_view<Char>(this->_buffer, this->_length).find_first_of(s, pos);
        }

        constexpr size_type find_first_of(Char c, size_type pos = 0) const noexcept
        {
            return basic_string_view<Char>(this->_buffer, this->_length).find_first_of(c, pos);
        }

        template<typename Type> requires (convertible_to<const Type&, basic_string_view<Char>> && !convertible_to<const Type&, const Char*>)
        constexpr size_type find_first_of(const Type &t, size_type pos = 0) const
        {
            return basic_string_view<Char>(this->_buffer, this->_length).find_first_of(basic_string_view<Char>(t), pos);
        }

        constexpr size_type find_first_not_of(const basic_string &str, size_type pos = 0) const noexcept
        {
            return basic_string_view<Char>(this->_buffer, this->_length).find_first_not_of(basic_string_view<Char>(str), pos);
        }

        constexpr size_type find_first_not_of(const Char *s, size_type pos, size_type count) const
        {
            return basic_string_view<Char>(this->_buffer, this->_length).find_first_not_of(s, pos, count);
        }

        constexpr size_type find_first_not_of(const Char *s, size_type pos = 0) const
        {
            return basic_string_view<Char>(this->_buffer, this->_length).find_first_not_of(s, pos);
        }

        constexpr size_type find_first_not_of(Char c, size_type pos = 0) const noexcept
        {
            return basic_string_view<Char>(this->_buffer, this->_length).find_first_not_of(c, pos);
        }

        template<typename Type> requires (convertible_to<const Type&, basic_string_view<Char>> && !convertible_to<const Type&, const Char*>)
        constexpr size_type find_first_not_of(const Type &t, size_type pos = 0) const
        {
            return basic_string_view<Char>(this->_buffer, this->_length).find_first_not_of(basic_string_view<Char>(t), pos);
        }

        constexpr size_type find_last_of(const basic_string &str, size_type pos = npos) const noexcept
        {
            return basic_string_view<Char>(this->_buffer, this->_length).find_last_of(basic_string_view<Char>(str), pos);
        }

        constexpr size_type find_last_of(const Char *s, size_type pos, size_type count) const
        {
            return basic_string_view<Char>(this->_buffer, this->_length).find_last_of(s, pos, count);
        }

        constexpr size_type find_last_of(const Char *s, size_type pos = npos) const
        {
            return basic_string_view<Char>(this->_buffer, this->_length).find_last_of(s, pos);
        }

        constexpr size_type find_last_of(Char c, size_type pos = npos) const noexcept
        {
            return basic_string_view<Char>(this->_buffer, this->_length).find_last_of(c, pos);
        }

        template<typename Type> requires (convertible_to<const Type&, basic_string_view<Char>> && !convertible_to<const Type&, const Char*>)
        constexpr size_type find_last_of(const Type &t, size_type pos = npos) const
        {
            return basic_string_view<Char>(this->_buffer, this->_length).find_last_of(basic_string_view<Char>(t), pos);
        }

        constexpr size_type find_last_not_of(const basic_string &str, size_type pos = npos) const noexcept
        {
            return basic_string_view<Char>(this->_buffer, this->_length).find_last_not_of(basic_string_view<Char>(str), pos);
        }

        constexpr size_type find_last_not_of(const Char *s, size_type pos, size_type count) const
        {
            return basic_string_view<Char>(this->_buffer, this->_length).find_last_not_of(s, pos, count);
        }

        constexpr size_type find_last_not_of(const Char *s, size_type pos = npos) const
        {
            return basic_string_view<Char>(this->_buffer, this->_length).find_last_not_of(s, pos);
        }

        constexpr size_type find_last_not_of(Char c, size_type pos = npos) const noexcept
        {
            return basic_string_view<Char>(this->_buffer, this->_length).find_last_not_of(c, pos);
        }

        template<typename Type> requires (convertible_to<const Type&, basic_string_view<Char>> && !convertible_to<const Type&, const Char*>)
        constexpr size_type find_last_not_of(const Type &t, size_type pos = npos) const
        {
            return basic_string_view<Char>(this->_buffer, this->_length).find_last_not_of(basic_string_view<Char>(t), pos);
        }

        friend constexpr basic_string operator+(const basic_string &lhs, const basic_string &rhs)
        {
            return basic_string<Char>(lhs).append(rhs);
        }

        friend constexpr basic_string operator+(const basic_string &lhs, const Char *rhs)
        {
            return basic_string<Char>(lhs).append(rhs);
        }

        friend constexpr basic_string operator+(const basic_string &lhs, Char rhs)
        {
            return basic_string<Char>(lhs).append(rhs);
        }

        friend constexpr basic_string operator+(const Char *lhs, const basic_string &rhs)
        {
            return basic_string<Char>(lhs).append(rhs);
        }

        friend constexpr basic_string operator+(Char lhs, const basic_string &rhs)
        {
            return basic_string<Char>(addressof(lhs), 1).append(rhs);
        }

        friend constexpr basic_string operator+(basic_string &&lhs, basic_string &&rhs)
        {
            const auto _size = lhs.size() + rhs.size();
            return (_size > lhs.capacity() && _size <= rhs.capacity()) ? move(rhs.insert(0, lhs)) : move(lhs.append(rhs));
        }

        friend constexpr basic_string operator+(basic_string &&lhs, const basic_string &rhs)
        {
            return move(lhs.append(rhs));
        }

        friend constexpr basic_string operator+(basic_string &&lhs, const Char *rhs)
        {
            return move(lhs.append(rhs));
        }

        friend constexpr basic_string operator+(basic_string &&lhs, Char rhs)
        {
            return move(lhs.append(1, rhs));
        }

        friend constexpr basic_string operator+(const basic_string &lhs, basic_string &&rhs)
        {
            return move(rhs.insert(0, lhs));
        }

        friend constexpr basic_string operator+(const Char *lhs, basic_string &&rhs)
        {
            return move(rhs.insert(0, lhs));
        }

        friend constexpr basic_string operator+(Char lhs, basic_string &&rhs)
        {
            return move(rhs.insert(0, 1, lhs));
        }

        friend constexpr bool operator==(const basic_string &lhs, const basic_string &rhs) noexcept
        {
            return lhs.compare(rhs) == 0;
        }

        friend constexpr bool operator==(const basic_string &lhs, const Char *rhs)
        {
            return lhs.compare(rhs) == 0;
        }

        friend constexpr auto operator<=>(const basic_string &lhs, const basic_string &rhs) noexcept
        {
            return lhs.compare(rhs) <=> 0;
        }

        friend constexpr auto operator<=>(const basic_string &lhs, const Char *rhs)
        {
            return lhs.compare(rhs) <=> 0;
        }

        friend constexpr void swap(basic_string &lhs, basic_string &rhs) noexcept (noexcept (lhs.swap(rhs)))
        {
            lhs.swap(rhs);
        }

        basic_string_view<Char> sub_view() const
        {
            return basic_string_view<Char>(_buffer, this->_length);
        }
        basic_string_view<Char> sub_view(size_type start) const
        {
            return basic_string_view<Char>(_buffer + start, this->_length - start);
        }
        basic_string_view<Char> sub_view(size_type start, size_type length) const
        {
            return basic_string_view<Char>(_buffer + start, (start + length) > this->_length ? this->_length - start : length);
        }
    };

    using string = basic_string<char>;
    using wstring = basic_string<wchar_t>;

    template<typename InputIt, typename Allocator = allocator<typename iterator_traits<InputIt>::value_type>>
    basic_string(InputIt, InputIt, Allocator = Allocator()) -> basic_string<typename std::iterator_traits<InputIt>::value_type, std::char_traits<typename std::iterator_traits<InputIt>::value_type>, Allocator>;

    template<typename Char, typename Traits, typename Allocator = allocator<Char>>
    explicit basic_string(basic_string_view<Char, Traits>, const Allocator & = Allocator()) -> basic_string<Char, Traits, Allocator>;

    template<typename Char, typename Traits, typename Allocator = allocator<Char>>
    basic_string(basic_string_view<Char, Traits>, size_t, size_t, const Allocator & = Allocator()) -> basic_string<Char, Traits, Allocator>;

    inline int stoi(const string &str, size_t *pos = nullptr, int base = 10)
    {
        auto cstr = str.c_str();
        char *ptr = const_cast<char*>(cstr);

        auto ret = strtol(cstr, &ptr, base);
        if (pos)
            *pos = cstr - ptr;

        return ret;
    }

    inline long stol(const string &str, size_t *pos = nullptr, int base = 10)
    {
        auto cstr = str.c_str();
        char *ptr = const_cast<char*>(cstr);

        auto ret = strtol(cstr, &ptr, base);
        if (pos)
            *pos = cstr - ptr;

        return ret;
    }

    inline long long stoll(const string &str, size_t *pos = nullptr, int base = 10)
    {
        auto cstr = str.c_str();
        char *ptr = const_cast<char*>(cstr);

        auto ret = strtoll(cstr, &ptr, base);
        if (pos)
            *pos = cstr - ptr;

        return ret;
    }

    namespace detail
    {
        template<typename Type>
        constexpr size_t to_chars_len(Type value)
        {
            constexpr Type b1 = 10;
            constexpr Type b2 = 100;
            constexpr Type b3 = 1000;
            constexpr Type b4 = 10000;

            for (size_t i = 1; ; i += 4, value /= b4)
            {
                if (value < b1)
                    return i;
                if (value < b2)
                    return i + 1;
                if (value < b3)
                    return i + 2;
                if (value < b4)
                    return i + 3;
            }
        }

        constexpr void to_chars(char *first, size_t len, auto val)
        {
            static constexpr char digits[201] =
                "0001020304050607080910111213141516171819"
                "2021222324252627282930313233343536373839"
                "4041424344454647484950515253545556575859"
                "6061626364656667686970717273747576777879"
                "8081828384858687888990919293949596979899";

            size_t pos = len - 1;
            while (val >= 100)
            {
                auto const num = (val % 100) * 2;
                val /= 100;
                first[pos] = digits[num + 1];
                first[pos - 1] = digits[num];
                pos -= 2;
            }
            if (val >= 10)
            {
                auto const num = val * 2;
                first[1] = digits[num + 1];
                first[0] = digits[num];
            }
            else first[0] = '0' + val;
        }

        template<signed_integral Type, unsigned_integral UType = make_unsigned_t<Type>>
        [[gnu::always_inline]]
        inline string to_string(Type value)
        {
            const auto negative = value < 0;
            const UType uvalue = negative ? static_cast<UType>(~value) + static_cast<UType>(1) : value;
            const auto length = to_chars_len(uvalue);
            string str(length + negative, '-');
            to_chars(&str[negative], length, uvalue);
            return str;
        }

        template<unsigned_integral Type>
        [[gnu::always_inline]]
        inline string to_string(Type value)
        {
            string str(to_chars_len(value), '\0');
            to_chars(&str[0], str.length(), value);
            return str;
        }
    } // namespace detail

    inline string to_string(int value)
    {
        return detail::to_string(value);
    }

    inline string to_string(long value)
    {
        return detail::to_string(value);
    }

    inline string to_string(long long value)
    {
        return detail::to_string(value);
    }

    inline string to_string(unsigned value)
    {
        return detail::to_string(value);
    }

    inline string to_string(unsigned long value)
    {
        return detail::to_string(value);
    }

    inline string to_string(unsigned long long value)
    {
        return detail::to_string(value);
    }

    template<>
    class hash<string>
    {
        public:
        size_t operator()(const string &str) const
        {
            return _hash(str.data(), str.length());
        }
    };

    template<typename Char, typename Traits, typename Allocator>
    class hash<basic_string<Char, Traits, Allocator>>
    {
        public:
        size_t operator()(const basic_string<Char, Traits, Allocator> &str) const
        {
            return _hash(str.data(), str.length());
        }
    };

    inline namespace literals
    {
        inline namespace string_literals
        {
            inline string operator""s(const char *str, size_t len)
            {
                return string(str, len);
            }
        } // inline namespace string_literals
    } // inline namespace literals
} // namespace std
using namespace std::literals::string_literals;

#endif
*/