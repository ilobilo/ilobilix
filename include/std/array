// Copyright (C) 2022  ilobilo

#pragma once

#include <initializer_list>
#include <type_traits>
#include <compare>
#include <cassert>

namespace std
{
    template<typename Type, size_t N>
    struct array
    {
        Type _array[N];

        using value_type = Type;
        using size_type = size_t;
        using difference_type = ptrdiff_t;
        using reference = value_type&;
        using const_reference = const value_type&;
        using pointer = value_type*;
        using const_pointer = const value_type*;

        using iterator = pointer;
        using const_iterator = const_pointer;

        constexpr reference at(size_type pos)
        {
            assert(pos < N);
            return this->_array[pos];
        }

        constexpr const_reference at(size_type pos) const
        {
            assert(pos < N);
            return this->_array[pos];
        }

        constexpr reference operator[](size_type pos)
        {
            return this->_array[pos];
        }

        constexpr const_reference operator[](size_type pos) const
        {
            return this->_array[pos];
        }

        constexpr reference front()
        {
            return this->_array[0];
        }

        constexpr const_reference front() const
        {
            return this->_array[0];
        }

        constexpr reference back()
        {
            return this->_array[N - 1];
        }

        constexpr const_reference back() const
        {
            return this->_array[N - 1];
        }

        constexpr pointer data()
        {
            return this->_array;
        }

        constexpr const_pointer data() const
        {
            return this->_array;
        }

        constexpr iterator begin()
        {
            return this->data();
        }

        constexpr const_iterator begin() const
        {
            return this->data();
        }

        constexpr const_iterator cbegin() const
        {
            return this->data();
        }

        constexpr iterator end()
        {
            return this->data() + N;
        }

        constexpr const_iterator end() const
        {
            return this->data() + N;
        }

        constexpr const_iterator cend() const
        {
            return this->data() + N;
        }

        [[nodiscard]] constexpr bool empty() const
        {
            return N == 0;
        }

        constexpr size_type size() const
        {
            return N;
        }

        constexpr size_type max_size() const
        {
            return N;
        }

        constexpr void fill(const_reference value)
        {
            for (size_type i = 0; i < N; i++)
                this->_array[i] = value;
        }

        constexpr void swap(array &other)
        {
            using std::swap;
            swap(this->_array, other._array);
        }

        friend constexpr bool operator==(const array &lhs, const array &rhs)
        {
            if (lhs.size() != rhs.size())
                return false;

            for (size_type i = 0; i < lhs.size(); i++)
                if (lhs[i] != rhs[i])
                    return false;

            return true;
        }

        // TODO: !=, <, >, <=, >=, <=>

        friend constexpr void swap(array &lhs, array &rhs)
        {
            lhs.swap(rhs);
        }
    };

    template<typename Type, typename ...U>
    array(Type, U...) -> array<Type, 1 + sizeof...(U)>;

    template<typename Type>
    struct tuple_size;

    template<typename Type, size_t N>
    struct tuple_size<array<Type, N> > : integral_constant<size_t, N> { };

    template<size_t I, typename Type>
    struct tuple_element;

    template<size_t I, typename Type, size_t N>
    struct tuple_element<I, array<Type, N>>
    {
        using type = Type;
    };

    namespace detail
    {
        template<typename Type, size_t N, size_t ...I>
        constexpr array<remove_cv_t<Type>, N> to_array_impl(Type (&a)[N], index_sequence<I...>)
        {
            return { { a[I]... } };
        }

        template<typename Type, size_t N, size_t ...I>
        constexpr array<remove_cv_t<Type>, N> to_array_impl(Type (&&a)[N], index_sequence<I...>)
        {
            return { { move(a[I])... } };
        }
    }

    template<typename Type, size_t N>
    constexpr array<remove_cv_t<Type>, N> to_array(Type (&a)[N])
    {
        return detail::to_array_impl(a, make_index_sequence<N> { });
    }

    template<class Type, size_t N>
    constexpr array<remove_cv_t<Type>, N> to_array(Type (&&a)[N])
    {
        return detail::to_array_impl(move(a), make_index_sequence<N> { });
    }

    template<typename ...Types>
    constexpr auto make_array(Types &&...values) -> array<decay_t<common_type_t<Types...>>, sizeof...(Types)>
    {
        return { std::forward<Types>(values)... };
    }

    template<size_t I, typename Type, size_t N>
    constexpr Type &get(array<Type, N> &a)
    {
        static_assert(I < N, "Array index is out of bounds");
        return a[I];
    }

    template<size_t I, typename Type, size_t N>
    constexpr Type &&get(array<Type, N> &&a)
    {
        static_assert(I < N, "Array index is out of bounds");
        return move(get<I>(a));
    }

    template<size_t I, typename Type, size_t N>
    constexpr const Type &get(const array<Type, N> &a)
    {
        static_assert(I < N, "Array index is out of bounds");
        return get<I>(a);
    }

    template<size_t I, typename Type, size_t N>
    constexpr const Type &&get(const array<Type, N> &&a)
    {
        static_assert(I < N, "Array index is out of bounds");
        return move(get<I>(a));
    }
} // namespace std