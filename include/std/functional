// Copyright (C) 2022-2024  ilobilo

#pragma once

#include_next <functional>
#include <utility>
#include <cstddef>
#include <cassert>

namespace std
{
    template<typename Func>
    class function;

    template<typename Ret, typename ...Args>
    class function<Ret (Args...)>
    {
        private:
        class callable
        {
            public:
            virtual ~callable() = default;
            virtual Ret invoke(Args &&...) = 0;
        };

        template<typename Func>
        class [[gnu::aligned(16)]] callableFunc : public callable
        {
            public:
            callableFunc(const Func &t) : t_(t) { }
            ~callableFunc() override = default;

            Ret invoke(Args &&...args) override
            {
                return t_(std::forward<Args>(args)...);
            }

            private:
            Func t_;
        };

        union {
            std::byte _stack[sizeof(void*) * 3];
            callable *_heap;
        };
        enum class st_type { none, stack, heap };
        st_type _st_type = st_type::none;

        callable *get_callable()
        {
            assert(this->_st_type != st_type::none);
            return this->_st_type == st_type::stack ? const_cast<callable*>(reinterpret_cast<const callable*>(this->_stack)) : this->_heap;
        }

        public:
        function() : _heap(nullptr), _st_type(st_type::none) { };

        template<typename Func>
        function(Func t)
        {
            if (sizeof(Func) <= (sizeof(void*) * 3))
            {
                this->_st_type = st_type::stack;
                new (this->_stack) callableFunc<Func>(t);
            }
            else
            {
                this->_st_type = st_type::heap;
                this->_heap = new callableFunc<Func>(t);
            }
        }

        ~function()
        {
            this->clear();
        }

        void clear()
        {
            if (this->_st_type == st_type::heap && this->_heap != nullptr)
                delete this->_heap;

            this->_heap = nullptr;
            this->_st_type = st_type::none;
        }

        template<typename Func>
        function &operator=(Func t)
        {
            if (this->_heap != nullptr)
            {
                delete this->_heap;
                this->_heap = nullptr;
            }

            if (sizeof(Func) <= (sizeof(void*) * 3))
            {
                this->_st_type = st_type::stack;
                new (this->_stack) callableFunc<Func>(t);
            }
            else
            {
                this->_st_type = st_type::heap;
                this->_heap = new callableFunc<Func>(t);
            }

            return *this;
        }

        Ret operator()(Args ...args)
        {
            assert(this->_st_type != st_type::none);
            return this->get_callable()->invoke(std::forward<Args>(args)...);
        }

        explicit operator bool() const
        {
            return this->_st_type != st_type::none;
        }
    };
} // namespace std