// Copyright (C) 2022  ilobilo

#pragma once

#include <utility>

namespace std
{
    // Copied from <frg/tuple.hpp> to fix circular dependency
    namespace _tuple
    {
        template<typename ...Types>
        struct storage;

        template<typename Type, typename ...Types>
        struct storage<Type, Types...>
        {
            storage() = default;

            storage(Type item, Types ...tail) : item(move(item)), tail(move(tail)...) { }

            template<typename ...UTypes>
            storage(const storage<UTypes...> &other) : item(other.item), tail(other.tail) { }

            template<typename ...UTypes>
            storage(storage<UTypes...> &&other) : item(move(other.item)), tail(move(other.tail)) { }

            Type item;
            storage<Types...> tail;
        };

        template<>
        struct storage<> { };

        template<size_t N, typename ...Types>
        struct nth_type;

        template<size_t N, typename Type, typename ...Types>
        struct nth_type<N, Type, Types...>
        {
            typedef typename nth_type<N - 1, Types...>::type  type;
        };

        template<typename Type, typename ...Types>
        struct nth_type<0, Type, Types...>
        {
            typedef Type type;
        };

        template<size_t N, typename ...Types>
        struct access_helper;

        template<size_t N, typename Type, typename ...Types>
        struct access_helper<N, Type, Types...> {
            static typename nth_type<N - 1, Types...>::type &access(storage<Type, Types...> &stor)
            {
                return access_helper<N - 1, Types...>::access(stor.tail);
            }
            static const typename nth_type<N - 1, Types...>::type &access(const storage<Type, Types...> &stor)
            {
                return access_helper<N - 1, Types...>::access(stor.tail);
            }
        };

        template<typename Type, typename ...Types>
        struct access_helper<0, Type, Types...>
        {
            static Type &access(storage<Type, Types...> &stor)
            {
                return stor.item;
            }

            static const Type &access(const storage<Type, Types...> &stor)
            {
                return stor.item;
            }
        };

    } // namespace _tuple

    template<typename ...Types>
    class tuple
    {
        private:
        _tuple::storage<Types...> _stor;

        public:
        tuple() = default;

        tuple(Types ...args) : _stor(move(args)...) { }

        template<typename ...UTypes>
        friend class tuple;

        template<size_t N, typename ...UTypes>
        struct _tuple_is_constructible
        {
            static constexpr bool value = is_constructible<typename _tuple::nth_type<N, Types...>::type, typename _tuple::nth_type<N, UTypes...>::type>::value && _tuple_is_constructible<N - 1, UTypes...>::value;
        };

        template<typename ...UTypes>
        struct _tuple_is_constructible<0, UTypes...>
        {
            static constexpr bool value = is_constructible<typename _tuple::nth_type<0, Types...>::type, typename _tuple::nth_type<0, UTypes...>::type>::value;
        };

        template<typename ...UTypes, typename = enable_if_t<_tuple_is_constructible<sizeof...(UTypes) - 1, const UTypes &...>::value>>
        tuple(const tuple<UTypes...> &other) : _stor(other._stor) { }

        template<typename ...UTypes, typename = enable_if_t<_tuple_is_constructible<sizeof...(UTypes) - 1, UTypes &&...>::value>>
        tuple(tuple<UTypes...> &&other) : _stor(move(other._stor)) { }

        template<size_t N>
        typename _tuple::nth_type<N, Types...>::type &get()
        {
            return _tuple::access_helper<N, Types...>::access(_stor);
        }
        template<size_t N>
        const typename _tuple::nth_type<N, Types...>::type &get() const
        {
            return _tuple::access_helper<N, Types...>::access(_stor);
        }
    };

    // Specialization to allow empty tuples.
    template<>
    class tuple<> { };

    template<typename Type>
    struct tuple_size;

    template<typename Type>
    inline constexpr size_t tuple_size_v = tuple_size<Type>::value;

    template<size_t I, typename Type>
    struct tuple_element;

    template<size_t I, typename Type>
    using tuple_element_t = typename tuple_element<I, Type>::type;

    template<typename ...Types>
    tuple<remove_reference_t<Types>...> make_tuple(Types && ...args)
    {
        return tuple<remove_reference_t<Types>...>(forward<Types>(args)...);
    }

    namespace _tuple
    {
        template<typename F, typename ...Args, size_t ...I>
        auto apply(F functor, const tuple<Args...> &args, index_sequence<I...>)
        {
            return functor(args.template get<I>()...);
        }

        template<typename F, typename ...Args, size_t ...I>
        auto apply(F functor, tuple<Args...> &&args, index_sequence<I...>)
        {
            return functor(move(args.template get<I>())...);
        }

        // Turns a set of tuple-like types into a tuple
        template<size_t, typename, typename, size_t>
        struct make_tuple_impl;

        template<size_t idx, typename Tuple, typename ...Types, size_t size>
        struct make_tuple_impl<idx, tuple<Types...>, Tuple, size> : make_tuple_impl<idx + 1, tuple<Types..., typename tuple_element<idx, Tuple>::type>, Tuple, size> { };

        template<size_t size, typename Tuple, typename ...Types>
        struct make_tuple_impl<size, tuple<Types...>, Tuple, size>
        {
            using type = tuple<Types...>;
        };

        // Helper struct to turn a tuple-like Type into a tuple<Type>
        template<typename Type>
        struct do_make_tuple : public make_tuple_impl<0, tuple<>, remove_reference_t<Type>, tuple_size<remove_reference_t<Type>>::value> { };

        // Computes the return type of a tuple_cat call
        template<typename...>
        struct tuple_combiner;

        template<>
        struct tuple_combiner<>
        {
            using type = tuple<>;
        };

        template<typename ...Types>
        struct tuple_combiner<tuple<Types...>>
        {
            using type = tuple<Types...>;
        };

        template<typename ...T1, typename ...T2, typename ...Remainder>
        struct tuple_combiner<tuple<T1...>, tuple<T2...>, Remainder...>
        {
            using type = typename tuple_combiner<tuple<T1..., T2...>, Remainder...>::type;
        };

        // Computes the return type of a tuple_cat call taking
        // a pack of tuple-like types
        template<typename ...Tuples>
        struct tuple_cat_result
        {
            typedef typename tuple_combiner<typename do_make_tuple<Tuples>::type...>::type type;
        };

        // Builds an integer_sequence of the tuple_size of the
        // first tuple passed to the template pack
        template<typename...>
        struct make_indices_from_1st;

        template<>
        struct make_indices_from_1st<>
        {
            typedef make_index_sequence<0> type;
        };

        template<typename Tuple, typename ...Tuples>
        struct make_indices_from_1st<Tuple, Tuples...>
        {
            typedef make_index_sequence<tuple_size<typename remove_reference<Tuple>::type>::value> type;
        };

        // Performs the actual concatenation for tuple_cat
        template<typename Ret, typename Indices, typename ...Tuples>
        struct tuple_concater;

        template<typename Ret, size_t ...Indices, typename Tuple, typename ...Tuples>
        struct tuple_concater<Ret, index_sequence<Indices...>, Tuple, Tuples...>
        {
            template<typename ...Res>
            static constexpr Ret do_concat(Tuple&& tp, Tuples&& ...tps, Res&& ...res)
            {
                typedef typename make_indices_from_1st<Tuples...>::type index;
                typedef tuple_concater<Ret, index, Tuples...> next;
                return next::do_concat(forward<Tuples>(tps)..., forward<Res>(res)..., move(tp.template get<Indices>())...);
            }
        };

        template<typename Ret>
        struct tuple_concater<Ret, index_sequence<>>
        {
            template <typename ...Res>
            static constexpr Ret do_concat(Res&& ...res)
            {
                return Ret(forward<Res>(res)...);
            }
        };
    } // namespace _tuple

    template<typename F, typename ...Args>
    auto apply(F functor, const tuple<Args...> &args)
    {
        return _tuple::apply(move(functor), args, index_sequence_for<Args...>());
    }

    template<typename F, typename ...Args>
    auto apply(F functor, tuple<Args...> &&args)
    {
        return _tuple::apply(move(functor), move(args), index_sequence_for<Args...>());
    }

    template <typename ...Tuples, typename Ret = typename _tuple::tuple_cat_result<Tuples...>::type>
    Ret tuple_cat(Tuples &&...args)
    {
        typedef typename _tuple::make_indices_from_1st<Tuples...>::type index;
        typedef _tuple::tuple_concater<Ret, index, Tuples...> concater;
        return concater::do_concat(forward<Tuples>(args)...);
    }

    template<typename ...Types>
    struct tuple_size<tuple<Types...>> : integral_constant<size_t, sizeof...(Types)> { };

    template<size_t I, typename ...Types>
    struct tuple_element<I, tuple<Types...>>
    {
        using type = typename _tuple::nth_type<I, Types...>::type;
    };

    template<size_t I, typename ...Types>
    constexpr typename tuple_element<I, tuple<Types...>>::type &get(tuple<Types...> &t)
    {
        return t.template get<I>();
    }

    template<size_t I, typename ...Types>
    constexpr typename tuple_element<I, tuple<Types...>>::type &&get(tuple<Types...> &&t)
    {
        return forward<typename tuple_element<I, tuple<Types...>>::type>(t.template get<I>());
    }

    template<size_t I, typename ...Types>
    constexpr typename tuple_element<I, tuple<Types...>>::type const &get(const tuple<Types...> &t)
    {
        return t.template get<I>();
    }

    template<size_t I, typename ...Types>
    constexpr typename tuple_element<I, tuple<Types...>>::type const &&get(const tuple<Types...> &&t)
    {
        return forward<typename tuple_element<I, tuple<Types...>>::type>(t.template get<I>());
    }

    // template<typename Type, typename ...Types>
    // constexpr Type &get(tuple<Types...> &t);

    // template<typename Type, typename ...Types>
    // constexpr Type &&get(tuple<Types...> &&t);

    // template<typename Type, typename ...Types>
    // constexpr const Type &get(const tuple<Types...> &t);

    // template<typename Type, typename ...Types>
    // constexpr const Type &&get(const tuple<Types...> &&t);

    template<typename ...Types>
    tuple<Types&&...> forward_as_tuple(Types &&...args)
    {
        return tuple<Types&&...>(forward<Types>(args)...);
    }
} // namespace std