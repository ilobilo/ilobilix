// Copyright (C) 2022  ilobilo

#pragma once

#include <climits>
#include <cstdint>

namespace std
{
    namespace detail
    {
        template<intmax_t Num, intmax_t Num1>
        struct gcd
        {
            static const intmax_t value = detail::gcd<Num1, Num % Num1>::value;
        };

        template<intmax_t Num>
        struct gcd<Num, 0>
        {
            static const intmax_t value = Num;
        };

        template<>
        struct gcd<0, 0>
        {
            static const intmax_t value = 1;
        };

        template<intmax_t Num>
        struct abs
        {
            static const intmax_t value = Num < 0 ? -Num : Num;
        };

        template<intmax_t Num>
        struct sign
        {
            static const intmax_t value = Num == 0 ? 0 : (Num < 0 ? -1 : 1);
        };

        template<intmax_t Num, intmax_t Num1, intmax_t = detail::sign<Num1>::value>
        class add;

        template<intmax_t Num, intmax_t Num1>
        class add<Num, Num1, 1>
        {
            private:
            static const intmax_t min = (1LL << (sizeof(intmax_t) * CHAR_BIT - 1)) + 1;
            static const intmax_t max = -min;

            static_assert(Num <= max - Num1, "Overflow in detail::add");

            public:
            static const intmax_t value = Num + Num1;
        };

        template<intmax_t Num, intmax_t Num1>
        class add<Num, Num1, 0>
        {
            public:
            static const intmax_t value = Num;
        };

        template<intmax_t Num, intmax_t Num1>
        class add<Num, Num1, -1>
        {
            private:
            static const intmax_t min = (1LL << (sizeof(intmax_t) * CHAR_BIT - 1)) + 1;
            static const intmax_t max = -min;

            static_assert(min - Num1 <= Num, "Overflow in detail::add");

            public:
            static const intmax_t value = Num + Num1;
        };

        template<intmax_t Num, intmax_t Num1>
        class mul
        {
            private:
            static const intmax_t nan = (1LL << (sizeof(intmax_t) * CHAR_BIT - 1));
            static const intmax_t min = nan + 1;
            static const intmax_t max = -min;
            static const intmax_t a_x = detail::abs<Num>::value;
            static const intmax_t a_y = detail::abs<Num1>::value;

            static_assert(Num != nan && Num1 != nan && a_x <= max / a_y, "Overflow in detail::mul");

            public:
            static const intmax_t value = Num * Num1;
        };

        template<intmax_t Num1>
        class mul<0, Num1>
        {
        public:
            static const intmax_t value = 0;
        };

        template<intmax_t Num>
        class mul<Num, 0>
        {
        public:
            static const intmax_t value = 0;
        };

        template<>
        class mul<0, 0>
        {
        public:
            static const intmax_t value = 0;
        };
    } // namespace detail

    template<intmax_t Num, intmax_t Denom = 1>
    class ratio
    {
        private:
        static constexpr const intmax_t na = detail::abs<Num>::value;
        static constexpr const intmax_t da = detail::abs<Denom>::value;
        static constexpr const intmax_t s = detail::sign<Num>::value * detail::sign<Denom>::value;
        static constexpr const intmax_t gcd = detail::gcd<na, da>::value;

        public:
        static constexpr const intmax_t num = s * na / gcd;
        static constexpr const intmax_t den = da / gcd;

        typedef ratio<num, den> type;
    };

    template<intmax_t Num, intmax_t Denom>
    constexpr const intmax_t ratio<Num, Denom>::num;

    template<intmax_t Num, intmax_t Denom>
    constexpr const intmax_t ratio<Num, Denom>::den;

    namespace detail
    {
        template<typename R1, typename R2>
        struct ratio_multiply
        {
            private:
            static const intmax_t gcd_n1_d2 = detail::gcd<R1::num, R2::den>::value;
            static const intmax_t gcd_d1_n2 = detail::gcd<R1::den, R2::num>::value;

            public:
            using type = typename ratio<detail::mul<R1::num / gcd_n1_d2, R2::num / gcd_d1_n2>::value, detail::mul<R2::den / gcd_n1_d2, R1::den / gcd_d1_n2>::value>::type;
        };
    } // namespace detail

    template<typename R1, typename R2>
    using ratio_multiply = typename detail::ratio_multiply<R1, R2>::type;

    namespace detail
    {
        template<typename R1, typename R2>
        struct ratio_divide
        {
            private:
            static const intmax_t gcd_n1_n2 = detail::gcd<R1::num, R2::num>::value;
            static const intmax_t gcd_d1_d2 = detail::gcd<R1::den, R2::den>::value;

            public:
            using type = typename ratio<detail::mul<R1::num / gcd_n1_n2, R2::den / gcd_d1_d2>::value, detail::mul<R2::num / gcd_n1_n2, R1::den / gcd_d1_d2>::value>::type;
        };
    } // namespace detail

    template<typename R1, typename R2>
    using ratio_divide = typename detail::ratio_divide<R1, R2>::type;

    namespace detail
    {
        template<typename R1, typename R2>
        struct ratio_add
        {
            private:
            static const intmax_t gcd_n1_n2 = detail::gcd<R1::num, R2::num>::value;
            static const intmax_t gcd_d1_d2 = detail::gcd<R1::den, R2::den>::value;

            public:
            using type = typename ratio_multiply<ratio<gcd_n1_n2, R1::den / gcd_d1_d2>, ratio<detail::add<detail::mul<R1::num / gcd_n1_n2, R2::den / gcd_d1_d2>::value, detail::mul<R2::num / gcd_n1_n2, R1::den / gcd_d1_d2>::value>::value, R2::den>>::type;
        };
    } // namespace detail

    template<typename R1, typename R2>
    using ratio_add = typename detail::ratio_add<R1, R2>::type;

    namespace detail
    {
        template<typename R1, typename R2, bool Odd = false, intmax_t Q1 = R1::num / R1::den, intmax_t M1 = R1::num % R1::den, intmax_t Q2 = R2::num / R2::den, intmax_t M2 = R2::num % R2::den>
        struct ratio_less1
        {
            static const bool value = Odd ? Q2 < Q1 : Q1 < Q2;
        };

        template<typename R1, typename R2, bool Odd, intmax_t _Qp>
        struct ratio_less1<R1, R2, Odd, _Qp, 0, _Qp, 0>
        {
            static const bool value = false;
        };

        template<typename R1, typename R2, bool Odd, intmax_t _Qp, intmax_t M2>
        struct ratio_less1<R1, R2, Odd, _Qp, 0, _Qp, M2>
        {
            static const bool value = !Odd;
        };

        template<typename R1, typename R2, bool Odd, intmax_t _Qp, intmax_t M1>
        struct ratio_less1<R1, R2, Odd, _Qp, M1, _Qp, 0>
        {
            static const bool value = Odd;
        };

        template<typename R1, typename R2, bool Odd, intmax_t _Qp, intmax_t M1, intmax_t M2>
        struct ratio_less1<R1, R2, Odd, _Qp, M1, _Qp, M2>
        {
            static const bool value = ratio_less1<ratio<R1::den, M1>, ratio<R2::den, M2>, !Odd>::value;
        };

        template<typename R1, typename R2, intmax_t S1 = detail::sign<R1::num>::value, intmax_t S2 = detail::sign<R2::num>::value>
        struct ratio_less
        {
            static const bool value = S1 < S2;
        };

        template<typename R1, typename R2>
        struct ratio_less<R1, R2, 1LL, 1LL>
        {
            static const bool value = ratio_less1<R1, R2>::value;
        };

        template<typename R1, typename R2>
        struct ratio_less<R1, R2, -1LL, -1LL>
        {
            static const bool value = ratio_less1<ratio<-R2::num, R2::den>, ratio<-R1::num, R1::den> >::value;
        };
    } // namespace detail

    template<typename R1, typename R2>
    struct ratio_less : bool_constant<detail::ratio_less<R1, R2>::value> {};

    template<typename R1, typename R2>
    struct ratio_greater : bool_constant<detail::ratio_less<R2, R1>::value> { };

    template<typename R1, typename R2>
    inline constexpr bool ratio_greater_v = ratio_greater<R1, R2>::value;
} // namespace std