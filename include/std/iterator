// Copyright (C) 2022  ilobilo

#pragma once

#include_next <iterator>

#include <initializer_list>
#include <type_traits>

namespace std
{
    struct input_iterator_tag { };
    struct output_iterator_tag { };
    struct forward_iterator_tag : public input_iterator_tag { };
    struct bidirectional_iterator_tag : public forward_iterator_tag { };
    struct random_access_iterator_tag : public bidirectional_iterator_tag { };
    struct contiguous_iterator_tag : public random_access_iterator_tag { };

    namespace detail
    {
        template<typename Iterator, class = void>
        struct default_iterator_traits { };

        template<typename Iterator>
        struct default_iterator_traits<
            Iterator,
            void_t<
                typename Iterator::iterator_category,
                typename Iterator::value_type,
                typename Iterator::difference_type,
                typename Iterator::pointer,
                typename Iterator::reference
            >
        >
        {
            using iterator_category = typename Iterator::iterator_category;
            using value_type = typename Iterator::value_type;
            using difference_type = typename Iterator::difference_type;
            using pointer = typename Iterator::pointer;
            using reference = typename Iterator::reference;
        };
    } // namespace detail

    template<typename Iterator>
    struct iterator_traits : detail::default_iterator_traits<Iterator> { };

    template<typename Type>
    struct iterator_traits<Type*>
    {
        using iterator_category = random_access_iterator_tag;
        using value_type = Type;
        using difference_type = ptrdiff_t;
        using pointer = Type*;
        using reference = Type&;
    };

    template<typename Type>
    struct iterator_traits<const Type*>
    {
        using iterator_category = random_access_iterator_tag;
        using value_type = Type;
        using difference_type = ptrdiff_t;
        using pointer = const Type*;
        using reference = const Type&;
    };

    template<typename>
	class reverse_iterator { };

    template<typename Type>
    constexpr auto size(const Type &c) -> decltype(c.size())
    {
        return c.size();
    }

    template<typename Type, size_t N>
    constexpr size_t size(const Type (&)[N])
    {
        return N;
    }

    template<typename Type>
    constexpr auto data(Type &c) -> decltype(c.data())
    {
        return c.data();
    }

    template<typename Type>
    constexpr auto data(const Type &c) -> decltype(c.data())
    {
        return c.data();
    }

    template<typename Type, size_t N>
    constexpr Type *data(Type (&array)[N])
    {
        return array;
    }

    template<typename Type>
    constexpr const Type *data(initializer_list<Type> il)
    {
        return il.begin();
    }

    template<typename C>
    constexpr auto begin(C &c) -> decltype(c.begin())
    {
        return c.begin();
    }

    template<typename C>
    constexpr auto begin(const C &c) -> decltype(c.begin())
    {
        return c.begin();
    }

    template<typename Type, size_t N>
    constexpr Type *begin(Type (&array)[N])
    {
        return array;
    }

    template<typename C>
    constexpr auto cbegin(const C &c) -> decltype(begin(c))
    {
        return begin(c);
    }

    template<typename C>
    constexpr auto end(C &c) -> decltype(c.end())
    {
        return c.end();
    }

    template<typename C>
    constexpr auto end(const C &c) -> decltype(c.end())
    {
        return c.end();
    }

    template<typename Type, size_t N>
    constexpr Type *end(Type (&array)[N])
    {
        return array + N;
    }

    template<typename C>
    constexpr auto cend(const C &c) -> decltype(end(c))
    {
        return end(c);
    }
} // namespace std